<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python3从零开始_12:continue、break和pass]]></title>
    <url>%2Funcategorized%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-12-continue%E3%80%81break%E5%92%8Cpass%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_11:循环控制语句]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-11-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[在上一篇中我们学习了条件控制语句，但仅仅只会条件控制还是不够的，我们还需要学习循环控制，比如，某些代码要重复执行，这时候就可以用到循环，设置好循环的条件，次数，以及退出循环的条件。 python的循环可以分为while循环和for循环，前者可以说是按条件的循环，后者时将可循环遍历的东西取出来循环，在后面我们会体会到它们的区别 while循环在讲while的时候，还是要和大家说说循环的一些必要的知识，第一点就是为何要循环，这个大家应该都知道，就是将重复的事情交给计算机去完成，减少重复的代码，提高可读性。第二点就是循环的条件，在做循环的时候，首先要知道循环的条件是什么，不能毫无条件就循环，而且这种条件必须是可终止的，不是无限的。第三点就是循环如何终止，循环不意味着无限的循环，总有停下来的时候，所以必须要有一个能使循环终止的方法。这些现在看起来不是很能明白，后面的例子中就会知道为什么要这样做了。 whilewhile的一般形式如下所示,while后面是循环的条件，接着依然是冒号，然后缩进，只要符合条件就执行while里面的代码。12while 判断条件： 语句 我们来和简单例子，计算从1加到100的结果12345678sum=0num=1while num&lt;=100: sum += num num += 1print(&quot;从1加到100的结果是:&quot;,sum) 结合一开始所提的三点我们来分析下代码，第一为何循环，因为要计算从1加到100，这种重复相加的事情就没必要写100次加法，用循环就可以实现了。第二循环的条件，这里循环的条件就是num&lt;=100。第三循环如何终止，其实这个终止就在循环条件里，当num大于100时就不成立了，就自动终止了循环，当然要能使条件不成立，就必须要在循环里添加能使条件不成立的变数，也就是代码里的num+=1，每次循环都加1，总有会加到大于100的时候。1从1加到100的结果是: 5050 这就是最简单的while循环，只要能明确三点基本上就不会有什么问题。 while…else不仅仅是if有else，while同样也有else，if的else是在if的条件不成立就执行else，而while里的else是如果我们不是除正常以外的其他方式退出循环，那么else分支将被执行，简单点说就是可以检测是否被中断，没有就会执行else。现在我们还没办法体现出他的作用，我们还没学一些提前退出的方法，而且这种while…else用的特别少，几乎用不上，了解即可。基本形式如下1234while 判断条件： 语句else: 语句 同样用一个简单例子演示下123456count = 0while count &lt; 5: print(count, &quot; 小于 5&quot;) count = count + 1else: print(count, &quot; 大于或等于 5&quot;) 1234560 小于 51 小于 52 小于 53 小于 54 小于 55 大于或等于 5 死循环前面说了循环要知道的三点，当第三点不存在的时候，就会出现无限循环的效果，称之为死循环。也不能说死循环就是错的，死循环也有被运用的时候，而且还非常好用，比如在做一些请求的时候，就会用到死循环，去不断的请求对方，或者不断的判断对方是否传输了数据。还有就是不希望程序被终止的时候。我们现在都是执行完就终止了程序，希望一直执行那就可以加上死循环。死循环最简单的方式就是条件为1，或者条件为True就行了123while 1: num = input(&quot;请输入数字:&quot;) print(&quot;你输入的数字是：&quot;,num) 这里没有使用int将输入的数字转换成数字是应为输出用的也是字符串，没必要转来转去了123456789请输入数字:5你输入的数字是： 5请输入数字:6你输入的数字是： 6请输入数字:18你输入的数字是： 18请输入数字:156你输入的数字是： 156请输入数字: 执行程序后，你会发现可以无限输入和输出，这种死循环要退出可以同时按Ctrl和c退出，突然的中断程序会报错，这个可以不管，不是代码的原因 forfor语句能够遍历任何序列的项目，比如列表，字典，序列，元组等。for能够明确循环次数，不像while，循环次数要在while里面通过代码去改变条件变数达到指定的次数，用for能更容易的实现次数的控制，而且for会比while给的更多，它能够直接遍历的带序列的值。 forfor的基本形式如下12for iterating_var in sequence: statements(s) 只是看基本形式无法理解，我们通过例子来说明，最简单的用法就是把序列的值遍历出来。1234lis=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]for i in lis: print(i) for后面的i是一个变量，这个变量名可以随意取，只要不是关键字即可，这个变量用来存储遍历出来的诶个值，lis是一个可遍历对象，也就是列表，然后for里面打印变量i1234abcd 可以看到，列表的每个值都给单独取出来了，也就是遍历，比起用索引一个一个输出方便了许多，这种是最简单的用法，for的用法很强大，只要是可遍历的对象都可以使用for遍历。 我们来学个方法，range()，range是对一系列数字进行迭代，我们用for来遍历，看是不是可以遍历出来12for i in range(5): print(i) range(5)将数字0到4变成了可遍历的序列。数字都是从0开始的1234501234 我们也可以让它从指定数字开始12for i in range(1,5): print(i) range(1,5)将数字1到2变成了可遍历的序列。前面是开始的数字，后面是结束的数字但不包括该数字1212 range()和索引很像，耶可以控制步长12for i in range(1,20,2): print(i) range(1,20,2)将数字1到20变成了可遍历的序列。前面是开始的数字，中间是结束的数字但不包括该数字，后面是步长12345678910135791113151719 for的用法不仅仅是这样简单的使用，但是刚开始学会简单的就可以了，一些其他的用法会在后面篇章的例子中慢慢讲解 for…elsefor也不甘示弱，也有else，和while一样，如果是正常结束的话就会执行else。1234for i in range(5): print(i)else: print(&quot;我正常结束了&quot;) 12345601234我正常结束了 关于while和for的嵌套怎么说呢，循环的嵌套刚开始的话，用起来会很混乱，自己都不知道怎么退出循环，所以我也不在这里打击大家，嵌套会在后面篇章例子中给大家一点一点讲解。这样才不会应为打击而对python失去信心。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_10:条件控制语句]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-10-%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[前面我们已经把python3的基本数据结构和运算符都学完了，接下来我们开始学习流程控制语句。结合之前学习的知识，我们可以在程序里实现一些基本的控制，比如满足某些条件执行某些语句，重复执行某些语句等。流程控制语句就时我们常说的判断、循环、跳转等，能控制程序的执行顺序。在python里，流程控制语句分为条件控制和循环控制。流程控制是学习编程语言必不可少的。 条件控制语句我们前面学习的程序都是按顺序执行的，从上往下一条一条的执行，这种按顺序的结构并不适合做复杂的程序，而条件控制可以帮我们在某些时候去做判断，根据不同的结果做不同的处理。Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。我们可以看下图简单了解条件语句的基本结构和执行过程。程序开始从上往下执行，遇到条件判断的时候先判断一下，如果是True往下执行代码1，如果是False就跳过代码1，结束程序。 if-else我们先来看下条件控制语句在程序里的基本结构。if-else是最基本的格式。需要注意的地方有几点 if条件后面是有冒号的，相当于其他语言的大括号 在条件语句的代码块是有缩进的。一般是一个Tab(4个空格，建议大家使用tab) 而已不写条件控制语句的else和else里的代码 其中第一和第二条是初学者最容易犯的错误，基本上都是在这两点上出错的。python是通过缩进来表示代码块层级的，一个表示一级，两个是两级，以此类推。同级下的缩进是相同的。我们通过一个例子来学习。如果今天妈妈给我50元以上的零钱，我就去麦当劳，买肥仔欢乐3件套。如果没有50元以上我去超市买包薯片得了。首先分析例子，可以看出是一个判断条件的例子，判断的方式是妈妈给了多少零花钱，条件是零花钱的数目大于50还是小于等于50。大于50就去麦当劳，否则去超市。好了分析完毕，我们通过代码来实现下1234567Pmoney = 0 #使用一个变量来接收得到的零花钱，初始是没有零花钱的，就初始化为0Pmoney = input(&quot;妈妈今天给了我多少零花钱:&quot;) #通过输入将值传递给变量if int(Pmoney)&gt;50: #Pmoney通过input()输入后得到的字符串，我们要用int强制转换成数字型的 print(&quot;好嗨哟~今天去麦当劳买薯条汉堡可乐吃！&quot;)else: print(&quot;钱太少了，还是去超市买包薯片吧！&quot;) 输入34的结果12妈妈今天给了我多少零花钱:34钱太少了，还是去超市买包薯片吧！ 输入65的结果12妈妈今天给了我多少零花钱:65好嗨哟~今天去麦当劳买薯条汉堡可乐吃！ 通过输入不同的数字得到的结果也就不一样了。这就是条件控制语句，也叫if语句，当if条件成立的时候执行执行if里的代码，否则执行else里的代码，为什么else不需要写条件？因为在判断的时候，如果零花钱要么大于50，要的小于等于50，不会出现其他结果，一个是大于50，那么另一个肯定就小于等于50啦 if-elif-elseif-else可以判断条件是否为真，类似2分类。但当我们需要判断多个条件结果的时候怎么办，用if-else也是可以实现的。我们在通过一个例子来说。我希望通过输入学生的成绩来判断学生成绩的等级，90分或以上是优，75分到89分是良，低于75分是差。先来分析，希望通过输入学生的成绩，说明我们会用到输入的操作。判断学生成绩的等级无疑是条件控制了。大于等于90的时候是优，大于等于75且小于等于89是良，低于75是差。12345678910Soc = input(&quot;请输入学生的成绩:&quot;)if int(Soc)&gt;=90: print(&quot;优&quot;)if int(Soc)&lt;90 and int(Soc)&gt;=75: print(&quot;良&quot;)if int(Soc)&lt;75: print(&quot;差&quot;) 这里因为多判断，所以可以将else省略，用多个if去判断，哪个条件为Ture就执行哪个if里的代码。当我们同时要判断多个条件的时候可以在条件的地方用逻辑运算符。因为if只判断条件最后的结果是True还是False。下面是分别输出94、85、74的结果123456请输入学生的成绩:94优请输入学生的成绩:85良请输入学生的成绩:74差 可以发现if-else也可以做到，但是这样做的一个缺点就是，每个if都需要判断。比如我输入94，第一个if判断一下，为True，执行里面的代码，执行完后又判断第二个if，不满足条件，再判断第三个if，不满足条件，这才结束程序。这样是不是觉得第二个和第三个if没必要去判断了，因为我满足其中一个了，那我就没必要再去和其它的判断了。这就可以用if-elif-else了，它就是为了解决这个问题的12345678910Soc = input(&quot;请输入学生的成绩:&quot;)if int(Soc)&gt;=90: print(&quot;优&quot;)elif int(Soc)&lt;75: print(&quot;差&quot;)else: print(&quot;良&quot;) elif的意思就是当上一个if条件不成立的时候就判断elif里的条件是否成立，否则elif是不会判断的。当输入94的时候，判断第一个if，条件成立，执行里面的代码，执行完后结束程序。当输入74的时候，判断第一个if，不成立，这时才会执行elif，判断elif的条件是否成立，成立执行里面的代码。如果运气不好，输入85，前面都不成立，这时才执行最后else。123456请输入学生的成绩:94优请输入学生的成绩:85良请输入学生的成绩:74差 输出的结果和用多个if是一样的。如果又学过其他编程语言的人都会知道，elif的原型就是else-if。上面的代码也可以还原成用if-sele123456789Soc = input(&quot;请输入学生的成绩:&quot;)if int(Soc)&gt;=90: print(&quot;优&quot;)else: if int(Soc)&lt;75: print(&quot;差&quot;) else: print(&quot;良&quot;) 这就是elif的原型了，当if不成立就else，然后else里面又嵌套一个if-else，嵌套的时候注意缩进，一定要注意缩进！123456请输入学生的成绩:94优请输入学生的成绩:85良请输入学生的成绩:74差 输出结果和执行效率都是一样的。如果我用了不止一个elif时呢？有多少elif就嵌套多少层，这样虽然执行效率和结果没区别，但是我们自己效率就大大下降了，而且可读性耶非常差，嵌套一般的不建议超过3层，大部分都嵌套到2层 三目运算符有时候我们可能为了得到一个简单结果用if-else去实现，比如，当x大于5时，y等于x，否则y等于x除于2。这就是一个简单if-else，我们可以通过用if-else代码来看下12345678x = int(input(&quot;请输入x的值:&quot;))y = 0if x&gt;20: y = xelse: y = x/2print(&quot;y的值为&quot;,y) 这里在input()的时候就先将输入值转换成int类型了，要在if之前声明一个y变量，不要再if-else里声明，这是作用域的问题，以后再讲，现在都先这样声明变量，变量声明再程序的开头。1234请输入x的值:35y的值为 35请输入x的值:16y的值为 8.0 我只是想判断x的值得到y值，这是个很简单的if-else判断程序，我们可以将它们简化，当然用if-else是没什么问题，完全可以，但是为了提高可读性可以简化下这种简单的if-else。用三目运算符。将if-else的结构简化成如下 为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号） 通过代码演示下123x = int(input(&quot;请输入x的值:&quot;))y = x if x&gt;20 else x/2print(&quot;y的值为&quot;,y) 输入输出都没变，将if-else简化了。if左边是条件为True的结构。else右边是条件为False的结果，if和else中间的判单的条件。我们可以按照这种顺序来读代码。先看if右边，也就是if和else中间，如果为True看if左边，否则看else右边1234请输入x的值:35y的值为 35请输入x的值:16y的值为 8.0 输出结果完全一样，而且代码还少了很多，可读性可非常高，这种三目运算只适合那些简单的if-else。一些复杂的就别用三目了。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_09:补充与提高]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-09-%E8%A1%A5%E5%85%85%E4%B8%8E%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[我们刚学习完数据结构，有些东西在前面都没提到，我把它们都放在这篇里，我标题可以看到，不仅仅是补充，还有一些可以提高自己逻辑的东西。有人会问，为什么前面不讲，其实是这样的，前面的都是一个类型一篇，如果我在前面就给你们讲，有不少初学者可能看的云里雾语，根本就看不明白，会大大的影响后面的学习兴趣。到这里，基本数据类型都讲完了，可以把那些补上，还有就是有些东西在后面会用到，也是一些基础，在以后的文章里我讲不再详细的讲解基础的知识。所以可以说这篇文章就是承上启下。 输出输出我们用了很多了，可以讲指定内容打印出来，这里就要讲输出的其他方式，普通输出，连接符输出和格式化输出。 普通输出普通输出就是我们经常使用的，用print()，想输出什么就什么，这个大家都用了那么久应该都了解了。1print(&quot;Hello&quot;) 1Hello 换输出变量，我们都知道输出变量只要直接使用变量名就可以了，前面一直我们都是一句输出就一个变量，现在我们可以尝试使用输出多个变量，减少多次使用print()1234a=[1,2,3,4]b=&quot;2&quot;print(a,b)print(&quot;我是列表：&quot;, a, &quot;我是字符串：&quot;, b) 纯输出多个变量时，直接用逗号隔开就可以了，如果还有字符串也是一样，一个字符串是一个整体，字符串和变量要隔开，依然使用逗号来隔开12[1, 2, 3, 4] 2我是列表： [1, 2, 3, 4] 我是字符串： 2 连接符输出连接符输出其实就是运用了字符串连接的操作，将多个字符串用+号连接起来，然后再输出1print(&quot;Hello &quot;+&quot;python3!&quot;) 1Hello python3! 同样的输出一个或者多个变量，和普通输出不一样了，因为连接符是将所有连接的字符看成一个整体，类型还是字符串，所以连接时的变量也需要时字符串类型的。1234a=&quot;1&quot;b=&quot;2&quot;print(a,b)print(&quot;我是：&quot;+a+&quot;我是：&quot;+b) 121 2我是：1我是：2 也可以混合普通和连接输出多变量，这种方法我不推荐大家使用，因为这样会使你的代码可读性很差，推荐大家就是用了哪种方式就哪种，不要混合使用。这里就不给大家演示了，我看多那么多代码也没看过有人使用混合的方式。有一点需要大家知道的，就是普通输出的变量可以时任何的，而连接输出的变量必须时字符串，相信大家都已经看出来。 格式化输出格式化输出就是用一些特定的符号在字符串里占个位，然后再通过变量将其输出，这种输出的方式非常灵活，如果输出的内容是经常变动的，非常推荐使用格式化输出。格式化输出又分为两种，一种是用%的方式，有人叫他旧格式化，还有一种是使用format()的方式，这是python自己的格式化。这两种的操作很相似，学会一种，另一种也就学会了。 %格式化%格式化会是来自C语言，学过C的同学应该再熟悉不过了，为什么python还会保留这种方式呢？是因为python本身是C演变过来的，其次保留这种方式会使其他编程语言转过来的人更加情切。要学会这种格式化首先我们要先知道每种占位符是意思，表示什么类型的数据。看到这里有不少同学就头疼了，那么多怎么记，其实这里比较常用的又%s,%d,%f,这三个是最常用的，记住这三个即可，其他的在要用的时候去查就可以了。1234name = &quot;Damow&quot;age = 24height = 1.73print(&quot;name is %s ,age is %d ,height is %fm.&quot; %(name ,age ,height)) 在字符串里用%占位符表示,后面紧接这%()，%()前面是没有逗号，表示要替换占位符的数据，里面按顺序对应上数据或变量即可，这里特别说明一点。你又多少占位符就应该有多少的替换数据，替换的顺序和类型必须和占位符一致，否则都会报错。1name is Damow ,age is 24 ,height is 1.730000m. %f输出的浮点数不怎么好看，谁会写自己的身高后面加那么多0，这里可以指定输出的长度1234name = &quot;Damow&quot;age = 24height = 1.73print(&quot;name is %s ,age is %d ,height is %.2fm.&quot; %(name ,age ,height)) %.2f表示保留小数点后2位。点表示小数点的意思，数字表示保留几位。1name is Damow ,age is 24 ,height is 1.73m. 如果你的变量是列表、元组、字典的话，可以使用下标或者键来替换12info = &#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24,&quot;height&quot;:1.73&#125;print(&quot;name is %s ,age is %d ,height is %.2fm.&quot; %(info[&quot;name&quot;] ,info[&quot;age&quot;] ,info[&quot;height&quot;])) 同样要注意顺序和类型1name is Damow ,age is 24 ,height is 1.73m. format()格式化format格式化就更加灵活了，不仅可以指定顺序，还可以将占位符作为关键字参数。1print(&quot;name is &#123;&#125; ,age is &#123;&#125; ,height is &#123;&#125;m.&quot; .format(&quot;Damow&quot;,24,1.73)) format同样也是先用占位符，这里的占位符就简单多了，只需要用{}就可以了，也不用指定占位符类型。然后加上.format()，同样不需要加逗号。这里注意的地方就一点，每个占位符必须有替换数据。1name is Damow ,age is 24 ,height is 1.73m. 上面这种是最基本的操作，默认按照顺序去替换占位符，我们也可以指定顺序，只需要在{}里加上要替换的位置,从0开始，如果你指定位置不存在就会报错，可以把他看成是元组的下标1print(&quot;name is &#123;1&#125; ,age is &#123;2&#125; ,height is &#123;0&#125;m.&quot; .format(1.73,&quot;Damow&quot;,24)) 1name is Damow ,age is 24 ,height is 1.73m. 按指定位置替换也会了，你们有没有发现，用数字0，1，2，3……这种方式要自己去数，而且0是什么，1是什么还要自己去查看，很麻烦。接下来就是用关键字的方式替换，同样的如果关键字不存在会报错，可以看成是字典的键值对1print(&quot;name is &#123;name&#125; ,age is &#123;age&#125; ,height is &#123;height&#125;m.&quot; .format(height=1.73,name=&quot;Damow&quot;,age=24)) 1name is Damow ,age is 24 ,height is 1.73m. 当我们要用变量的值替换时，可以在format里直接用变量,如果用了变量，同样可以按照顺序替换，也可以指定位置，如果还带有关键字替换的时候，format里的关键字必须放在所有非关键字的后面，没有使用关键字的{}必须指定位置，否则会报错12345height=1.73name=&quot;Damow&quot;age=24print(&quot;name is &#123;&#125; ,age is &#123;&#125; ,height is &#123;&#125;m.&quot; .format(name,age,height))print(&quot;name is &#123;0&#125; ,age is &#123;1&#125; ,height is &#123;height&#125;m.&quot; .format(name,age,height=height)) 12name is Damow ,age is 24 ,height is 1.73m.name is Damow ,age is 24 ,height is 1.73m. 如果你使用了列表或元组的话，{}里的位置必须指明，只有一个也需要指明，然后加上索引即可123info = [1.73,&quot;Damow&quot;]info2 = [24]print(&quot;name is &#123;0[1]&#125; ,age is &#123;1[0]&#125; ,height is &#123;0[0]&#125;m.&quot; .format(info,info2)) 1name is Damow ,age is 24 ,height is 1.73m. 字典的话可以将占位符的关键字作为参数替换字典里键对应的值，在format()里加上**变量名12info = &#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24,&quot;height&quot;:1.73&#125;print(&quot;name is &#123;name&#125; ,age is &#123;age&#125; ,height is &#123;height&#125;m.&quot; .format(**info)) 1name is Damow ,age is 24 ,height is 1.73m. 还有一些就是数字格式化的东西，这个说实话，我也不怎么常用，就是在{}里加个:，然后接着格式的方式，我一般用到什么去查下就是了。如果有兴趣可以自己照着下面的图片去尝试。 输入有输出就有输入，有时候数据并不是我们定的，希望由用户自己去定数据，这时候输入就是最好的办法，让用户自己输入数据，然后用print输出反馈给用户。输入和输出差不多，使用input()，一般情况下输入都会存在变量里，所以我们可以用变量来接收用户输入的数据。12name = input()print(&quot;your name is &quot;,name) input()直接赋值给变量即可，然后可以使用print将输入的变量值打印出来，当执行的时候你会发现，什么都没有打印，空白一片，这时你可以通过键盘输入文字，然后按下回车，就会将print的内容打印出来。这里为了更好的演示，将执行的过程截成图片了 可以看到执行后什么都没有然后我们输入文字按下回车知后就有结果了 可是什么提示信息都没有，用户也不知道要输入什么，体验会非常的差，偶们可以给用户一些提示信息，这样用户会知道我要输入什么内容。12name = input(&quot;请输入你的名字：&quot;)print(&quot;your name is &quot;,name) 执行后可以看到有提示信息了，请输入你的名字：，然后就等待用户输入，输入完后按下回车，结果就打印出来了，这样用户的体验就会比什么提示信息都没有要好12请输入你的名字：Damowyour name is Damow 在这里要对说几句，就是不管你输入的是什么，数据类型都会是字符串，即使你输入的是个数字，它也会成为字符串。1234name = input(&quot;请输入你的名字：&quot;)age = input(&quot;请输入你的年龄：&quot;)print(&quot;你的名字是&#123;0&#125;，你的年龄是&#123;1&#125;&quot; .format(name,age))print(&quot;name的数据类型&#123;0&#125;,age数据类型&#123;1&#125;&quot; .format(type(name),type(age))) 1234请输入你的名字：Damow请输入你的年龄：24你的名字是Damow，你的年龄是24name的数据类型&lt;class &apos;str&apos;&gt;,age数据类型&lt;class &apos;str&apos;&gt; 数据类型转换我们学了数字、字符串、布尔、元组、列表、字典和集合，有时候会想将数字变成列表，或者字符串变成数字，这时候就会涉及到数据类型的转换，而且数据类型的转换规则是非常严格的，稍有不对都会失败。这里只讲平时用的比较多的转换。 数字整形和浮点型之间转换浮点型转为整形可以使用int()，而整形转为浮点型使用float() 1234num = 10num2 = 3.1415print(&quot;num是&#123;&#125;,num的数据类型为&#123;&#125;,转换成浮点型&#123;&#125;,转换成浮点型后的类型为&#123;&#125;&quot;.format(num,type(num),float(num),type(float(num))))print(&quot;num2是&#123;&#125;,num2的数据类型为&#123;&#125;,转换成整型&#123;&#125;,转换成整型后的类型为&#123;&#125;&quot;.format(num2,type(num2),int(num2),type(int(num2)))) 12num是10,num的数据类型为&lt;class &apos;int&apos;&gt;,转换成浮点型10.0,转换成浮点型后的类型为&lt;class &apos;float&apos;&gt;num2是3.1415,num2的数据类型为&lt;class &apos;float&apos;&gt;,转换成整型3,转换成整型后的类型为&lt;class &apos;int&apos;&gt; 数字与字符串之间转换字符串转数字和整形与浮点型之间转换一样，整形就用int()，浮点型就用float()。但是要特别注意的是字符串转数字的字符必须是数字，如果字符是浮点类型的，只能转换成浮点型。 12345str = &quot;1&quot;num = int(str)num2 = float(str)print(&quot;num=&#123;&#125;,num2=&#123;&#125;&quot;.format(num,num2))print(&quot;num的数据类型为&#123;&#125;,num2的数据类型为&#123;&#125;&quot;.format(type(num),type(num2))) 12num=1,num2=1.0num的数据类型为&lt;class &apos;int&apos;&gt;,num2的数据类型为&lt;class &apos;float&apos;&gt; 将数字转换成字符使用str()即可 1234num = 3.1415str = str(num)print(&quot;num=&#123;&#125;,str=&#123;&#125;&quot;.format(num,str))print(&quot;num的数据类型为&#123;&#125;,str的数据类型为&#123;&#125;&quot;.format(type(num),type(str))) 12num=3.1415,str=3.1415num的数据类型为&lt;class &apos;float&apos;&gt;,str的数据类型为&lt;class &apos;str&apos;&gt; 转换成列表，字符串、元组、集合都可以直接转换成列表，字典也是可以，但是字典只将键转换成列表，使用list()转换 123456lis1 = list(&quot;abc&quot;)lis2 = list((1,2,3))lis3 = list(&#123;&quot;a&quot;,1&#125;)lis4 = list(&#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24&#125;)print(type(lis1),type(lis2),type(lis3))print(lis4,type(lis4)) 12&lt;class &apos;list&apos;&gt; &lt;class &apos;list&apos;&gt; &lt;class &apos;list&apos;&gt;[&apos;name&apos;, &apos;age&apos;] &lt;class &apos;list&apos;&gt; 转换成元组，字符串、列表、集合都可以直接转换成元组,字典也是可以，但是字典只将键转换成元组，使用tuple()转换 123456tup1 = tuple(&quot;abc&quot;)tup2 = tuple([1,2,3])tup3 = tuple(&#123;&quot;a&quot;,1&#125;)tup4 = tuple(&#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24&#125;)print(type(tup1),type(tup2),type(tup3))print(tup4,type(tup4)) 12&lt;class &apos;tuple&apos;&gt; &lt;class &apos;tuple&apos;&gt; &lt;class &apos;tuple&apos;&gt;(&apos;name&apos;, &apos;age&apos;) &lt;class &apos;tuple&apos;&gt; 转换成集合，字符串、列表、元组都可以直接转换成集合,字典也是可以，但是字典只将键转换成集合，使用set()转换 123456se1 = set(&quot;abc&quot;)se2 = set((1,2,3))se3 = set([&quot;a&quot;,1])se4 = set(&#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24&#125;)print(type(se1),type(se2),type(se3))print(se4,type(se4)) 12&lt;class &apos;set&apos;&gt; &lt;class &apos;set&apos;&gt; &lt;class &apos;set&apos;&gt;&#123;&apos;name&apos;, &apos;age&apos;&#125; &lt;class &apos;set&apos;&gt; 转换成字典,转成字典比较特殊，因为字典是键值对。所以一般用列表或元组来转换,必须满足几个条件，有键必须有值，一个键值对是一个列表或者元组，必须且只能嵌套一次 123456tup = ([&apos;name&apos;, &apos;dahua&apos;], [&apos;age&apos;, 18])lis = [(&apos;name&apos;, &apos;dahua&apos;), (&apos;age&apos;, 18)]dic1 = dict(tup)dic2 = dict(lis)print(dic1,type(dic1))print(dic2,type(dic2)) 12&#123;&apos;name&apos;: &apos;dahua&apos;, &apos;age&apos;: 18&#125; &lt;class &apos;dict&apos;&gt;&#123;&apos;name&apos;: &apos;dahua&apos;, &apos;age&apos;: 18&#125; &lt;class &apos;dict&apos;&gt; 注释当代码量多的时候或者回味许久之前的代码，可能自己都不记得自己写的是什么意思，这是后就可以做一些注释，方便自己或者别人阅读代码。注释的内容是不会执行的，所以可以放心的使用 单行注释单行注释是用#，井号后面的内容不管多少都是注释，但是#只注释一行，不会注释到其他行的内容12#打印输出注释两个文字print(&quot;注释&quot;) #我是注释，只注释井号后面的一行哦 1注释 多行注释多行注释可以用一对三个单引号或者一对三个双引号，在引号里，无论多少行都是注释的内容12345678910111213&apos;&apos;&apos;一对三个单引号我是多行注释的第一行我是多行注释的第二行我是多行注释的第三行&apos;&apos;&apos;print(&quot;多行注释&quot;)&quot;&quot;&quot;一对三个双引号我也是多行注释的第一行我也是多行注释的第二行我也是多行注释的第三行&quot;&quot;&quot; 1多行注释 统计，最大和最小值有时候需要统计字符串、列表、元组等数据的值有多少个，或者找出最大值，最小值，python也同样提供了快捷的操作。len()统计数量，max()最大值，min()最大和最小值123456str = &quot;abcdefg&quot;lis = [1,2,3,4,5]tup = (10,11,12,13)print(len(str),max(str),min(str))print(len(lis),max(lis),min(lis))print(len(tup),max(tup),min(tup)) 1237 g a5 5 14 13 10]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_08:集合]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-08-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[这篇将介绍基本数据结构中的最后一个——集合(set)，集合是一个无序的不重复元素序列。集合的使用是比较简单的，再加上前面学习了元组、列表、字典后，集合变得更加简单了。从集合是一个无序的不重复元素序列这句话中可以看出，集合的特性，第一点是集合是无序的，和字典一样。第二点是不重复，也就是说里面的元素不会重复，都是唯一了。其实在平时集合用的不会像其他数据类型一样使用的那么频繁，主要是在一些场合下做去重的时候会用的比较多。 创建集合集合的创建和字典很像，同样是用{}表示，不同的是，集合不存在键值对，就是普通的值，依然用逗号隔开。元素类型必须是单一的。12set1 = &#123;1,&quot;hello&quot;,2,&quot;hello&quot;,1&#125;print(set1) 从输出可以看到，集合自动帮我们去掉了重复的元素，这也是集合最大的作用。1&#123;1, 2, &apos;hello&apos;&#125; 当我们需要创建一个空集合的时候，就不能直接使用{}来创建，因为{}是用来创建空字典的，我们应该使用set()方法12set2 = set()print(&quot;set2 = &quot;,set) 输出的结果是set()，因为是空的，如果是用{}表示的话，就表示空字典了，所以空的集合用set()表示1set2 = set() 删除集合是无序的，所以集合不支持索引和切片，也就是说不能找到指定的元素位置，所以只能删除整个集合。但是，删除某个元素还是可以的，用remove()方法。1234set4 = &#123;1,2,3,1,4,6,3,4&#125;print(&quot;set4 = &quot;,set4)del set4print(set4) 12345set4 = &#123;1, 2, 3, 4, 6&#125;Traceback (most recent call last): File &quot;C:\Users\as338\Desktop\a.py&quot;, line 4, in &lt;module&gt; print(set4)NameError: name &apos;set4&apos; is not defined 用remove()删除集合的某个元素，要删除某个元素的前提条件是，你必须知道集合里是否有该元素。1234set5 = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;d&quot;&#125;print(&quot;set5 = &quot;,set5)set5.remove(&quot;b&quot;)print(&quot;set5 = &quot;,set5) 12set5 = &#123;&apos;d&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;&#125;set5 = &#123;&apos;d&apos;, &apos;c&apos;, &apos;a&apos;&#125; 运算当你看到这你可能就疑惑了，怎么前面讲了创建和删除，就到运算了，添加，查询，修改呢？我只能说，集合不存在这些快捷操作，的确是有这些操作，但是它们都是用方法实现的，所以这些我都放到方法里讲，运算才是集合的核心部分。 什么是交集、并集、差集、对称差集这些东西很好理解，就是又没有相同的部分，不相同的部分之类的，下面是百度百科的介绍 交集：集合论中，设A，B是两个集合，由所有属于集合A且属于集合B的元素所组成的集合，叫做集合A与集合B的交集并集：给定两个集合A，B，把他们所有的元素合并在一起组成的集合，叫做集合A与集合B的并集差集：设A，B是两个集合，由所有属于A且不属于B的元素组成的集合，叫做集合A减集合B(或集合A与集合B之差)，类似地，对于集合A,B，我们把集合{x/x∈A,且x￠B}叫做A与B的差集对称差集：集合A与集合B中所有不属于A∩B的元素的集合 是不是看的一头雾水，是就对了，因为我也看的很难受，把这些用通俗的话来说就是下面的意思. 交集：两个集合中共同的元素组成的集合. 并集：两个集合所有的并去掉重复的元素组成的集合. 差集：在集合1不在集合2的元素集合. 对称差集：两个集合中除去相同集合的元素组成的集合就是这么简单的意思，就是有没有共同元素的问题 交集交集用&amp;符号做运算，得到的结果是一个新的集合。12345set6 = &#123;1,2,3,4,5&#125;set7 = &#123;1,3,5,7,9&#125;print(&quot;set6 = &quot;,set6)print(&quot;set7 = &quot;,set7)print(&quot;set6和set7的交集是：&quot;,set6&amp;set7) 两个集合通过做交集运算后，得到两个集合共同拥有的元素的集合123set6 = &#123;1, 2, 3, 4, 5&#125;set7 = &#123;1, 3, 5, 7, 9&#125;set6和set7的交集是： &#123;1, 3, 5&#125; 并集并用|符号做运算，得到的结果是一个新的集合。12345set6 = &#123;1,2,3,4,5&#125;set7 = &#123;1,3,5,7,9&#125;print(&quot;set6 = &quot;,set6)print(&quot;set7 = &quot;,set7)print(&quot;set6和set7的并集是：&quot;,set6|set7) 两个集合通过做并集运算后，得到两个集合所有的且不重复的集合123set6 = &#123;1, 2, 3, 4, 5&#125;set7 = &#123;1, 3, 5, 7, 9&#125;set6和set7的并集是： &#123;1, 2, 3, 4, 5, 7, 9&#125; 差集差集用-符号做运算，得到的结果是一个新的集合。12345set6 = &#123;1,2,3,4,5&#125;set7 = &#123;1,3,5,7,9&#125;print(&quot;set6 = &quot;,set6)print(&quot;set7 = &quot;,set7)print(&quot;set6和set7的差集是：&quot;,set6-set7) 两个集合通过做差集运算后，得到在集合set6有的元素，并且在集合set7没有的元素的集合。如果反过来set7-set6结果就是在集合set7有的元素，并且在集合set6没有的元素的集合。（9和7）123set6 = &#123;1, 2, 3, 4, 5&#125;set7 = &#123;1, 3, 5, 7, 9&#125;set6和set7的差集是： &#123;2, 4&#125; 对称差集对称差集用^符号做运算，得到的结果是一个新的集合。12345set6 = &#123;1,2,3,4,5&#125;set7 = &#123;1,3,5,7,9&#125;print(&quot;set6 = &quot;,set6)print(&quot;set7 = &quot;,set7)print(&quot;set6和set7的对称差集是：&quot;,set6^set7) 两个集合通过做对称差集运算后，得到两个集合中除去相同元素，剩下的元素组成的集合123set6 = &#123;1, 2, 3, 4, 5&#125;set7 = &#123;1, 3, 5, 7, 9&#125;set6和set7的对称差集是： &#123;2, 4, 7, 9&#125; 方法集合因为添加，删除，查询都是靠方法实现的，所以方法会比较多。操作都会很简单 add()为集合添加元素，如果添加的元素已存在的话，原集合不会发生改变。123456set8 = &#123;1,2,3&#125;print(&quot;set8 = &quot;,set8)set8.add(4)print(&quot;添加元素4后的set8 = &quot;,set8)set8.add(2)print(&quot;添加元素2后的set8 = &quot;,set8) 123set8 = &#123;1, 2, 3&#125;添加元素4后的set8 = &#123;1, 2, 3, 4&#125;添加元素2后的set8 = &#123;1, 2, 3, 4&#125; update()给集合添加元素,update和add的区别就是，add只能添加1个元素，添加的是什么就是什么，而update可以添加多个，可以是列表，元组，字典等，如果添加字符串类型，添加进去后会被拆成单个的字符串123456set8 = &#123;1,2&#125;print(&quot;set8 = &quot;,set8)set8.update(&quot;abcd&quot;)print(&quot;set8 = &quot;,set8)set8.update([&quot;asd&quot;],[&quot;zxc&quot;])print(&quot;set8 = &quot;,set8) 123set8 = &#123;1, 2&#125;set8 = &#123;1, 2, &apos;d&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;&#125;set8 = &#123;1, 2, &apos;asd&apos;, &apos;zxc&apos;, &apos;d&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;&#125; clear()移除集合中的所有元素1234set8 = &#123;1,2,3&#125;print(&quot;set8 = &quot;,set8)set8.clear()print(&quot;set8 = &quot;,set8) 12set8 = &#123;1, 2, 3&#125;set8 = set() remove()移除指定元素,如果元素不存在，则会发生错误。1234set8 = &#123;1,2,3&#125;print(&quot;set8 = &quot;,set8)set8.remove(2)print(&quot;set8 = &quot;,set8) 12set8 = &#123;1, 2, 3&#125;set8 = &#123;1, 3&#125; pop()删除的是集合中的第一个元素，如果集合中没有元素就会引发KeyError错误12345678set8 = &#123;1,2&#125;print(&quot;set8 = &quot;,set8)set8.pop()print(&quot;set8 = &quot;,set8)set8.pop()print(&quot;set8 = &quot;,set8)set8.pop()print(&quot;set8 = &quot;,set8) 1234567set8 = &#123;1, 2&#125;set8 = &#123;2&#125;set8 = set()Traceback (most recent call last): File &quot;C:\Users\as338\Desktop\a.py&quot;, line 7, in &lt;module&gt; set8.pop()KeyError: &apos;pop from an empty set&apos; discard()删除集合中指定的元素,和remove的区别在于，discard先会在集合里查找是否有该元素，如果有将其删除，如果没有什么都不会发生123456set8 = &#123;1,2&#125;print(&quot;set8 = &quot;,set8)set8.discard(1)print(&quot;set8 = &quot;,set8)set8.discard(3)print(&quot;set8 = &quot;,set8) 123set8 = &#123;1, 2&#125;set8 = &#123;2&#125;set8 = &#123;2&#125; copy()拷贝一个集合，浅拷贝1234set8 = &#123;1,2&#125;print(&quot;set8 = &quot;,set8)set9 = set8.copy()print(&quot;set9 = &quot;,set9) 12set8 = &#123;1, 2&#125;set9 = &#123;1, 2&#125; intersection()返回两个或更多集合的交集12345678set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;set10 = &#123;1,2,4,5,7&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)print(&quot;set10 = &quot;,set10)a = set8.intersection(set9,set10)print(&quot;a = &quot;,a) 1234set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set10 = &#123;1, 2, 4, 5, 7&#125;a = &#123;1, 5&#125; intersection_update()获取两个或更多集合的交集，并在原集合中删除非交集元素。intersection_update和intersection区别， intersection是返回一个新的集合，而intersection_update是在原始的集合上移除非交集的元素。12345678set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;set10 = &#123;1,2,4,5,7&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)print(&quot;set10 = &quot;,set10)set8.intersection_update(set9,set10)print(&quot;set8 = &quot;,set8) 1234set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set10 = &#123;1, 2, 4, 5, 7&#125;set8 = &#123;1, 5&#125; union()返回两个或更多集合的并集且不重复12345678set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;set10 = &#123;1,2,4,5,7&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)print(&quot;set10 = &quot;,set10)a = set8.union(set9,set10)print(&quot;a = &quot;,a) 1234set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set10 = &#123;1, 2, 4, 5, 7&#125;a = &#123;1, 2, 3, 4, 5, 7, 9&#125; difference()返回两个集合的差集123456set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)a = set8.difference(set9)print(&quot;a = &quot;,a) 123set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;a = &#123;2, 4&#125; difference_update()获取两个集合的差集，并在原集合中删除非差集元素。difference_update和difference的区别在于difference返回两个集合的差集，而difference_update是在原来的集合中移除非差集元素123456set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)set8.difference_update(set9)print(&quot;set8 = &quot;,set8) 123set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set8 = &#123;2, 4&#125; symmetric_difference()返回两个集合的对称差集。123456set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)a = set8.symmetric_difference(set9)print(&quot;a = &quot;,a) 123set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;a = &#123;2, 4, 7, 9&#125; symmetric_difference_update()获取两个集合的对称差集，并在原集合中删除对称非差集元素。symmetric_difference_update和symmetric_difference的区别在于symmetric_difference返回两个集合的对称差集，而symmetric_difference_update是在原来的集合中移除非对称差集元素123456set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)set8.symmetric_difference_update(set9)print(&quot;set8 = &quot;,set8) 123set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set8 = &#123;2, 4, 7, 9&#125; isdisjoint()判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。123456set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)a = set8.isdisjoint(set9)print(&quot;a = &quot;,a) 注意如果没有返回的是True，否则返回的False。这个设计是个谜123set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;a = False issubset()判断集合的所有元素是否都包含在指定集合中，如果是则返回 True，否则返回 False。12345678910set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;set10 = &#123;1,3,5&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)print(&quot;set10 = &quot;,set10)a = set8.issubset(set9)b = set10.issubset(set8)print(&quot;a = &quot;,a)print(&quot;b = &quot;,b) 12345set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set10 = &#123;1, 3, 5&#125;a = Falseb = True issuperset()判断指定集合的所有元素是否都包含在原始的集合中，如果是则返回 True，否则返回 False。issuperset和issubset的区别在于谁是谁的子集，issuperset判断自身是否是完全包含在括号里，而issuperset正好相反，判断括号里的是否完全包含自身12345678910set8 = &#123;1,2,3,4,5&#125;set9 = &#123;1,3,5,7,9&#125;set10 = &#123;1,3,5&#125;print(&quot;set8 = &quot;,set8)print(&quot;set9 = &quot;,set9)print(&quot;set10 = &quot;,set10)a = set8.issuperset(set9)b = set8.issuperset(set10)print(&quot;a = &quot;,a)print(&quot;b = &quot;,b) 12345set8 = &#123;1, 2, 3, 4, 5&#125;set9 = &#123;1, 3, 5, 7, 9&#125;set10 = &#123;1, 3, 5&#125;a = Falseb = True]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_07:字典]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-07-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典（Dictionary）在Python中是一种可变的容器模型，它是通过一组键（key）值（value）对组成，这种结构类型通常也被称为映射，或者叫关联数组，也有叫哈希表的。 因为字典是通过映射实现的，所以它的速度非常快，而且取值也是特别的方便，只需要建立键值对即可实现 键值对在学习字典前必须要先了解什么是键值对。键值对是存储数据最简单的一种组织形式，键对应着值。我们可以举个简单生活例子，就拿我们生活中的字典来说，小时候学汉字时都会用到字典，我们要查一个汉字的意思时，首先都会在字母表里找到要查的汉字，然后翻到给出的页数，最后在要找的汉字里得到汉字的意思。这就是我们查字典的方法，这和python的字典很像，所以python也将这种数据类型称为字典。我们可以把字母表里的所有字母看成时键，页数看成时值，这样，我们只要知道字母就能知道页数。把这种键和值叫键值对 增字典的创建也很简单，和前面学习的元组、列表差不多。用{}来表示字典，依然用逗号隔开，每个键值对用:表示，冒号左边时键，右边时值。其中键必须是唯一的，值可以是任何的数据类型，但是键必须是不可变的数据类型（数字、字符串、元组）。12dic1 = &#123;&quot;one&quot;:1,2:&quot;two&quot;,&quot;three&quot;:3&#125;print(dic1) 1&#123;&apos;one&apos;: 1, 2: &apos;two&apos;, &apos;three&apos;: 3&#125; 从输出的结果也能看出，大括号括起来的字典类型，有冒号，逗号。这也时最简单，最基本的创建方式了 删删除也是类似的，因为字典是可变的，所以可以删除指定的键值对，也可删除整个字典。在字典里索引就不再是数字了，而是对应的键，因为字典是无序的，虽然我们是按顺序写，但是在计算机里是无序的存储，用数字索引并不能索引到。这一点需要注意下。123456dic2 = &#123;&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;del dic2[&apos;Name&apos;]print(dic2)print(&quot;----------------------------&quot;)del dic2print(dic2) 删除依然用del。删除指定的依然是用[]，把要删除的键值对的键放进去就可以删除了。123456&#123;&apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;----------------------------Traceback (most recent call last): File &quot;.\a.py&quot;, line 11, in &lt;module&gt; print(dic2)NameError: name &apos;dic2&apos; is not defined 查字典的查询也是一样，可用通过键直接查询到值,当然也可以直接查询整个字典1234dic3 = &#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24&#125;print(&quot;name = &quot;,dic3[&quot;name&quot;])print(&quot;age = &quot;,dic3[&quot;age&quot;])print(dic3) 123name = Damowage = 24&#123;&apos;name&apos;: &apos;Damow&apos;, &apos;age&apos;: 24&#125; 改字典的修改只能是修改键对应的值，键是无法修改的，只能添加一个新的键值对，要注意键要是唯一的，不能重复。修改字典只要在变量后面的[]里输入要修改的键，然后直接赋值即可，如果该键存在的会就是修改对应的值，如果不存在的话就添加一个新的键值对。123456dic4 = &#123;1:&quot;one&quot;&#125;print(dic4)dic4[1] = 1print(dic4)dic4[&quot;name&quot;] = &quot;Damow&quot;print(dic4) 123&#123;1: &apos;one&apos;&#125;&#123;1: 1&#125;&#123;1: 1, &apos;name&apos;: &apos;Damow&apos;&#125; 方法字典有一些方法，这些方法都很实用，而且很方便，用的也比较多。有许多都是还没怎么学习到的知识，可以先放着，那些知识后面全都会讲到的。 clear()删除字典内所有元素1234dic5 = &#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24&#125;print(&quot;dic5 = &quot;,dic5)dic5.clear()print(&quot;dic5 = &quot;,dic5) 12dic5 = &#123;&apos;name&apos;: &apos;Damow&apos;, &apos;age&apos;: 24&#125;dic5 = &#123;&#125; copy()返回一个字典的浅复制(什么是浅复制，深复制，后面会讲到)1234dic5 = &#123;&quot;name&quot;:&quot;Damow&quot;,&quot;age&quot;:24&#125;print(&quot;dic5 = &quot;,dic5)dic6 = dic5.copy()print(&quot;dic6 = &quot;,dic6) 12dic5 = &#123;&apos;name&apos;: &apos;Damow&apos;, &apos;age&apos;: 24&#125;dic6 = &#123;&apos;name&apos;: &apos;Damow&apos;, &apos;age&apos;: 24&#125; fromkeys()创建一个新字典,()里第一个输入的是一个元祖，元祖里的值将成为字典的键，第二个是可选项，如果没填值就是None，否则将是你填写的值123456dic7 = &#123;&#125;tup = (&quot;name&quot;,&quot;age&quot;)dic8 = dic7.fromkeys(tup)print(&quot;dic8 = &quot;,dic8)dic9 = dic7.fromkeys(tup,10)print(&quot;dic9 = &quot;,dic9) 12dic8 = &#123;&apos;name&apos;: None, &apos;age&apos;: None&#125;dic9 = &#123;&apos;name&apos;: 10, &apos;age&apos;: 10&#125; get()返回指定键的值，如果值不在字典中返回None12345dic10 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;name = dic10.get(&quot;Name&quot;)phone = dic10.get(&quot;phone&quot;)print(&quot;name = &quot;,name)print(&quot;phone = &quot;,phone) 12name = Damowphone = None items()以列表返回可键和值元组数组。123dic11 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;tup = dic11.items()print(&quot;tup = &quot;,tup) 1tup = dict_items([(&apos;Name&apos;, &apos;Damow&apos;), (&apos;Age&apos;, 27)]) keys()返回一个键的迭代器12dic12 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;print(dic12.keys()) 1dict_keys([&apos;Name&apos;, &apos;Age&apos;]) pop()删除字典给定键所对应的值，返回值为被删除的值,()第一个是键，第二个是如果键不存在将返回该值12345dic13 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;pop = dic13.pop(&quot;Age&quot;)pop2 = dic13.pop(&quot;a&quot;,&quot;不存在&quot;)print(pop)print(pop2) 1227不存在 popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)。如果字典已经为空，却调用了此方法，就报出KeyError错误。123dic13 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;pop3 = dic13.popitem()print(pop3) 1(&apos;Age&apos;, 27) setdefault()和get()方法类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值。123456dic14 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;name = dic14.setdefault(&quot;Name&quot;,None)sex = dic14.setdefault(&quot;Sex&quot;,None)print(&quot;name = &quot;,name)print(&quot;sex = &quot;,sex)print(&quot;dic14 = &quot;,dic14) 123name = Damowsex = Nonedic14 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27, &apos;Sex&apos;: None&#125; update()把新字典更新到旧字典里，如果键存在，则替换旧字典键对应的值。1234dic15 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;dic16 = &#123;&apos;Sex&apos;: &apos;female&apos;, &apos;Age&apos;: 22&#125;dic15.update(dic16)print(&quot;dic15 = &quot;,dic15) 1dic15 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 22, &apos;Sex&apos;: &apos;female&apos;&#125; values()返回一个值的迭代器12dic17 = &#123;&apos;Name&apos;: &apos;Damow&apos;, &apos;Age&apos;: 27&#125;print(dic17.values()) 1dict_values([&apos;Damow&apos;, 27])&#125;]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_06:列表]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-06-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[我们上一篇学完了元组，这一篇马上进入列表的学习中，因为列表和元组非常相似，我们趁热打铁，只要懂了元组，列表也就很简单了 列表是属于可变数据结构，它与元组很相似，唯一的区别就是，数据可变，其他的基本上都一样，操作也是，所以这一篇讲的会比较快 增首先我们同样先学习创建列表，列表的创建和元组一样，但是列表用[]括起来，而不是用()，这点需要大家留意12345678910lis1 = [1,2,3]lis2 = [&quot;I&quot;,&quot;Love&quot;,&quot;Python&quot;]lis3 = [False,True]lis4 = [1,&quot;python&quot;,True,(20,30),[&apos;a&apos;,&apos;b&apos;]]lis5 = [&apos;a&apos;]print(&quot;lis1=&quot;,lis1)print(&quot;lis2=&quot;,lis2)print(&quot;lis3=&quot;,lis3)print(&quot;lis4=&quot;,lis4)print(&quot;lis5=&quot;,lis5) 创建的操作和元组一模一样，只是括号变了，多个元素依然用逗号隔开，同样可以是多种类型的元素，也可以嵌套，如果元组都懂，这个完全没难度了,在列表了，如果只有一个元素时，可以不再用逗号去强调，只要和平时使用的方法使用就可以了12345lis1= [1, 2, 3]lis2= [&apos;I&apos;, &apos;Love&apos;, &apos;Python&apos;]lis3= [False, True]lis4= [1, &apos;python&apos;, True, (20, 30), [&apos;a&apos;, &apos;b&apos;]]lis5= [&apos;a&apos;] 输出也是一样，为了方便区分，同样用[]表示，省去了type()的时间。 删删除也是一样，使用del可以将整个变量删掉，但是，列表时可变数据结构，那它就可以修改列表里的元素，这也就是意味着可以只针对某个元素做操作，比如删除列表里某个元素12345lis6 = [1,2,3]print(lis6)print(&apos;-----------------&apos;)del lis6print(lis6) 这里删除整个就不多说了123456[1, 2, 3]-----------------Traceback (most recent call last): File &quot;.\a.py&quot;, line 11, in &lt;module&gt; print(lis6)NameError: name &apos;lis6&apos; is not defined 我们回顾下上一篇里的元素下标，每个元素都有一个下标号，从左往右是从0开始，从右往左是从-1开始，索引用[]，切片只需要在[]里加:，左边是开始的下标，右边是结束的下标减1，如果再加个:就表示步数，可以跳跃。 好了，这些想起来就会容易很多，从下面开始，基本上就是这些操作了。12345678910111213141516lis7 = [1,2,3,4,5,6,7,8]print(lis7)del lis7[2]print(lis7)print(&apos;-----------------&apos;)lis8 = [1,2,3,4,5,6,7,8]print(lis8)del lis8[2:5]print(lis8)print(&apos;-----------------&apos;)lis9 = [1,2,3,4,5,6,7,8]print(lis9)del lis9[::2]print(lis9) 可以看到lis7是通过索引删除指定下标的元素，lis8通过切片，而lis9还怎加的步数，这些操作是不是和元组一样，所以元组那一篇搞懂了，这就很简单了12345678[1, 2, 3, 4, 5, 6, 7, 8][1, 2, 4, 5, 6, 7, 8]-----------------[1, 2, 3, 4, 5, 6, 7, 8][1, 2, 6, 7, 8]-----------------[1, 2, 3, 4, 5, 6, 7, 8][2, 4, 6, 8] 查查就通过下标索引和切片，这些都是讲过的，只不过把元组换成了列表1234lis10 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;]print(lis10)print(lis10[-7:-2])print(lis10[1:8:3]) 操作上基本都没什么难度了，再以前看来很难得现在变得很简单了。123[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;][&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;][&apos;b&apos;, &apos;e&apos;, &apos;h&apos;] 这里就不再玩作死了…现在来说都不是作死了，都已经没挑战性了。有兴趣得话，大家可以自己去尝试下 改因为列表是可变的，所以可以修改元素，而修改元素说白了就是用下标查找到该元素，然后重新赋值，就这么简单1234567891011121314lis11 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]print(&quot;lis11修改前：&quot;,lis11)lis11[1] = 1print(&quot;lis11修改后：&quot;,lis11)lis12 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]print(&quot;lis12修改前：&quot;,lis12)lis12[2:4] = &quot;hi&quot;,&quot;python&quot;print(&quot;lis12修改后：&quot;,lis12)lis13 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]print(&quot;lis13修改前：&quot;,lis13)lis13[::3] = 2,3print(&quot;lis13修改后：&quot;,lis13) 这里有一点需要注意得，就是你要修改多少元素就要赋值多少个元素，否则就是报错，这点大家要注意，一般很少范围性得修改，修改单个比较多。123456lis11修改前： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]lis11修改后： [&apos;a&apos;, 1, &apos;c&apos;, &apos;d&apos;]lis12修改前： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]lis12修改后： [&apos;a&apos;, &apos;b&apos;, &apos;hi&apos;, &apos;python&apos;, &apos;e&apos;, &apos;f&apos;]lis13修改前： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]lis13修改后： [2, &apos;b&apos;, &apos;c&apos;, 3, &apos;e&apos;] 运算说到运算就想到了元组的+，*，in，同样在列表也是一样，而且效果也是一样的1234567lis14 = [1,2]lis15 = [4,5]lis16 = lis14+lis15lis17 = lis14*3print(lis16)print(lis17)print(4 in lis15) 123[1, 2, 4, 5][1, 2, 1, 2, 1, 2]True 方法最后说说列表的方法，因为是可变的数据结构，所以方法会比元组多，而且都很实用 count()统计某个元素在列表中出现的次数12lis18 = [1,2,3,1,1,2,4,5]print(lis18.count(1)) 13 index()从列表中找出某个值第一个匹配项的索引位置12lis18 = [1,2,3,1,1,2,4,5]print(lis18.index(2)) 11 可以指定开始到结束的下标 12lis18 = [1,2,3,1,1,2,4,5]print(lis18.index(1,2,5)) 13 clear()清空列表12lis18 = [1,2,3,1,1,2,4,5]print(lis18.clear()) 1None None就表示空的意思，什么都没有，None也是一个数据类型，只有唯一的值，就是None append()在列表末尾添加新的对象123lis18 = [1,2,3,1,1,2,4,5]lis18.append(&apos;a&apos;)print(lis18) 1[1, 2, 3, 1, 1, 2, 4, 5, &apos;a&apos;] 这个方法需要注意一下，append()是没有返回值的。如果你print(lis18.append(‘a’))结果是None，因为没有返回的结果。如果用另外的变量去接收也是一样没效果，所以append只是自己末尾添加后，仍然将数据存在自己 pop()移除列表中的一个元素（默认最后一个元素），并且返回该元素的值123lis18 = [1,2,3,1,1,2,4,5]print(lis18.pop())print(lis18) 125[1, 2, 3, 1, 1, 2, 4] 同样可以指定下标123lis18 = [1,2,3,1,1,2,4,5]print(lis18.pop(1))print(lis18) 122[1, 3, 1, 1, 2, 4, 5] sort()对原列表进行排序123lis18 = [1,2,3,1,1,2,4,5]lis18.sort()print(lis18) 1[1, 1, 1, 2, 2, 3, 4, 5] 和append一样没有返回值 reverse()反向列表中元素123lis18 = [1,2,3,1,1,2,4,5]lis18.reverse()print(lis18) 1[5, 4, 2, 1, 1, 3, 2, 1] remove()移除列表中某个值的第一个匹配项123lis18 = [1,2,3,1,1,2,4,5]lis18.remove(2)print(lis18) 1[1, 3, 1, 1, 2, 4, 5] extend()在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）1234lis18 = [1,2,3,1,1,2,4,5]lis19 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]lis18.extend(lis19)print(lis18) 1[1, 2, 3, 1, 1, 2, 4, 5, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] insert()将对象插入列表123lis18 = [1,2,3,1,1,2,4,5]lis18.insert(2,&apos;ccc&apos;)print(lis18) 1[1, 2, &apos;ccc&apos;, 3, 1, 1, 2, 4, 5] 逗号后面表示插入的数据，逗号前面表示数据插入的下标号 copy()复制列表123lis18 = [1,2,3,1,1,2,4,5]lis19 = lis18.copy()print(lis19) 1[1, 2, 3, 1, 1, 2, 4, 5]]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_05:元组]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-05-%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这篇我们单独来讲讲python中元组,元组是属于不可变数据结构，这却成为了python的标准数据结构，这里面也肯定有它优越之处，那么我们就来学习下元组这个数据结构 在前面数据结构那篇我们介绍到数据结构可以分为可变和不可变，元组就是不可变的数据结构之一，也就是说如果我们定义了一个元组类型的数据结构，那么它里面的数据是不可再做修改，正因为这种特性，往往将一些安全系数较高的数据都会定义成元组，这样可以防止在做数据操作的时候误把数据的原值破坏掉，所以元组的操作很简单，可以分为创建、删除、访问、索引、切片还有一些简单的内置方法，接下来我们一个一个来说 元组的创建与删除创建创建元组和创建其他数据类型一样，但是要注意的是，创建元组的时候必须将数据用小括号括起来，这样表明这个数据是元组类型，在括号里可以有多个数据，可以是不同类型的数据，我们目前学了数字、字符串和布尔类型，那么我们来来尝试创建这三种类型的元组。还有在创建多个数据的时候用逗号隔开。 1234567tup1 = (1,2,3)tup2 = (&quot;I&quot;,&quot;Love&quot;,&quot;Python&quot;)tup3 = (False,True)print(&quot;tup1=&quot;,tup1)print(&quot;tup2=&quot;,tup2)print(&quot;tup3=&quot;,tup3) 这里分别创建了3个元组，里面的值分别是数值、字符串和布尔类型，通过用逗号将多个值隔开，并且都用小括号括起来，这就是元组的创建123tup1= (1, 2, 3)tup2= (&apos;I&apos;, &apos;Love&apos;, &apos;Python&apos;)tup3= (False, True) 通过输出也可以看到，输出变量的值也是括号括起来的，这样可以一眼就看出，这个变量是元组类型的，这也方便了我们直接查看数据的类型，不用每次都用type()去查看 既然我们能创建元组了，里面的值类型而且还可以是其他类型的，那我们来混合这些类型试下12tup4 = (1,&quot;python&quot;,True,(20,30))print(&quot;tup4=&quot;,tup4) 可以看到，我们混合了类型也是可以的，而且在元组里面还创建元组类型的值，这就是嵌套，这也是允许的，在后面会讲到的列表、字典、集合都是一样的1tup4= (1, &apos;python&apos;, True, (20, 30)) 输出的结果也是一样，括号括起来的，在里面的元组也是一样，这里就没什么好说的了，接下来说当创建元组时，只有一个值的时候的问题，这也是初学者出错比较多的比方 我面前面已经知道创建元组要用括号括起来，多个值的时候用逗号隔开，那我创建一个是不是就不用逗号了呢？这个问题我们看下面的代码来解释123456tup5 = (1)print(&quot;tup5=&quot;,tup5)print(type(tup5))tup6 = (1,)print(&quot;tup6=&quot;,tup6)print(type(tup6)) 我们先来思考一个问题，括号在不同的地方有着不同的作用，比如在数学中，括号表示优先运算的意思，在元组中表示是元组类型，机器不像人类一样会思考，在机器里括号就是一个符号，那我用括号括起来一个数字，你说他是数字类型还是元组类型，恐怕你自己都很难说清楚，更何况机器了，所以python想了一个办法，就是元组只有一个值的时候用逗号区分，我们从代码里已经看到了，创建一个值得时候依然用了逗号，这样告诉机器，我这是元组，别把它当成是数字啦。1234tup5= 1&lt;class &apos;int&apos;&gt;tup6= (1,)&lt;class &apos;tuple&apos;&gt; 通过结果能很明显得看到他们得类型是不一样得，即使不用type()，也能看出来，一个没有括号括起来得，表示数值，一个用括号括起来得表示元组，而且同样有一个逗号，方便我们去区分这个括号表示的是什么 删除元组的特性相信大家都很熟悉了，就是元组的值是不可变的，创建好就是这样，没法改变，意味着我们不可以删除某个值，但可以把元组给删除12345tup7 = (1,2,3)print(tup7)print(&apos;-----------------&apos;)del tup7print(tup7) 创建元组我就不多讲了，删除一个元组可以使用del关键字，del tup7表示将元组变量整个删除123456(1, 2, 3)-----------------Traceback (most recent call last): File &quot;.\a.py&quot;, line 25, in &lt;module&gt; print(tup7)NameError: name &apos;tup7&apos; is not defined 我们通过输出可以看到，在没有删除之前是可以输出变量的，但是当我们删除之后再输出，可以看到报错了，NameError: name ‘tup7’ is not defined变量tup7不存在，这就表明我们已经彻底删除了元组tup7，关键字del不仅适用元组，其他数据类型也同样可以使用，这里就不操作给大家看了，大家可以自己去尝试下 元组的索引和切片下标我们先来理解什么是下标，下标就是元素的标号，通常就是用整数表示，从左往右0开始，从右往左-1开始，这里文字不好理解看图来解释 创建一个元组tup，里面的值是1，2，3，4，5。我们可以把tup看成是一个整体，里面的值是这个整体的元素，按照顺序，从左边开始，第一个元素的下标就是0，第二个就是1…以此类推，如果我们从右边开始，最右边的就是-1，倒数第二个就是-2…以此类推，可以多看看这张图，自己琢磨下，下标的用法在python里使用的频率是特别多的，所以这个一定要掌握 索引我们知道输出元组的值只要直接使用变量名就可以，但是我只想输出指定的元素，或者指定的下标呢？这就会用到索引1234tup8 = (1,2,3,4,5)print(tup8)print(tup8[3])print(tup8[-3]) 我们要输出指定下标时，可以通过[]来指定下标，如果要从左开始数就用正数，从右就要从负数，可以结合上面的图看，这里很多初学者都会弄混淆，因为左边是从0开始，很容易以为从1开始数，所以这里大家需要多练习123(1, 2, 3, 4, 5)43 还有一个初学者经常出错的地方就是超出下标，当索引的时候超出下标时就会报错，这也时报错比较多的12tup8 = (1,2,3,4,5)print(tup8[5]) 1234Traceback (most recent call last): File &quot;.\a.py&quot;, line 28, in &lt;module&gt; print(tup8[5])IndexError: tuple index out of range 这就是超出下标的报错，元组的下标超出了范围 切片我们可以输出指定下标的元素了，那我要输出某个下标到某个下标的元素呢，这就是切片，就像把一个整体，去掉头，去掉尾，咔嚓脆…回归正题，切片和索引差不多，也是用[]来表示，只不过里面用:来表示范围1234tup9 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;)print(tup9)print(tup9[1:4])print(tup9[-3:-1]) 在[]里，:左边表示开始的下标，右边表示结束的下标，但是真正的就说下标其实时你所写的下标减一，也就是说[1:4]，真正的范围时从下标1到下标3，而[-3:-1]的范围时-3到-2，这点需要大家注意123(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;)(&apos;b&apos;, &apos;c&apos;, &apos;d&apos;)(&apos;c&apos;, &apos;d&apos;) 花式作死为什么我会要弄个花式作死呢，用为切片这个东西很有趣，可以完成各种各样的切片，非常的花式，所以我们就来玩花式作死12345tup10 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;)print(tup10)print(tup10[5:])print(tup10[:8])print(tup10[:]) 先来简单的，上面说了用[]和:做切片，这里我们看代码:的又一侧是没有写下标，或者两边都不写，运行结果没有报错，说明python是会自动为我们加上的，如果左边没写，默认就是从左边第一个元素开始，右边没写就默认是到右边结尾最后一个元素，当然两边都不写那就是错左边第一个元素开始到右边最后一个元素结尾，这个很好理解1234(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;)(&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;) 我们来升级下作死1234tup10 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;)print(tup10)print(tup10[5::2])print(tup10[::3]) 代码里又多了一个:，这是什么鬼，前面是切片，后面又是什么，其实后面的冒号是步数的意思，就是说，在前面切片的范围里，我再按照指定的数进行跳跃，比如print(tup10[5::2])，如果没有后面的冒号就是从下标5的元素开始到右边最后一个元素，范围是(‘f’, ‘g’, ‘h’, ‘i’, ‘j’, ‘k’, ‘l’)，现在我加了步数是2，就是每隔两个的元素，从f开始，然后跳到第2个h，然后又跳到第2个j，以此类推。同样的print(tup10[::3])，范围是全部，步数是3。123(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;)(&apos;f&apos;, &apos;h&apos;, &apos;j&apos;, &apos;l&apos;)(&apos;a&apos;, &apos;d&apos;, &apos;g&apos;, &apos;j&apos;) 接下来终极作死123tup11=(1,2,3,(4,5,(6,7)))print(tup11)print(tup11[1::2][-1][::2]) 这个应该会难道一大片人，虽然这种代码很少会出现，但是能理解就可以了，不做强求我们来分析下print(tup11[1::2][-1][::2])的结果为什么是(4, (6, 7))12(1, 2, 3, (4, 5, (6, 7)))(4, (6, 7)) 首先我们要知道嵌套的元组是如何访问的，当访问嵌套元组时可以在后面再加个[]，表示访问下一嵌套，如果还有，就再来一个[]，就这样一直到你要访问的为止。我们来一步一步分析 tup11[1::2]，相信大家都能看出这个的结果是(2, (4, 5, (6, 7)))，这个我就不说了 tup11[1::2][-1]，我们上一步得到结果是(2, (4, 5, (6, 7)))，现在我们要嵌套[-1]，索引右边开始第一个元素，结果就是(4, 5, (6, 7)) tup11[1::2][-1][::2]，既然的到结果是(4, 5, (6, 7))，那下一个嵌套[::2]，就是从左边第一个元素到右边最后一个元素，加上步数是2，第一个就是4，跳到第2个，(6, 7)，所以结果就是(4, (6, 7)) 如果这个没搞懂也没关系，只要上面两个作死能理解就可以了，还有就是嵌套的元组如何访问的，懂这些就可以了 元组的运算元组也是可以做运算的，只不过不是数值之间的运算，只是合并和复制而已123456tup12 = (1,2)tup13 = (4,5)tup14 = tup12+tup13tup15 = tup12*2print(tup14)print(tup15) tup14 = tup12+tup13其实就是将元组tup12和元组tup13合并成一个新的元组而已tup15 = tup12*2就是将元组tup12复制两份然后合成一个新的元组12(1, 2, 4, 5)(1, 2, 1, 2) 不仅仅是+和*，还有in和is也同样可以使用1234tup12 = (1,2)tup13 = (4,5)print(4 in tup13)print((1,2) is tup12) 12TrueTrue 元组的方法终于到最后一个了，元组的方法，因为元组是不可变的，所以方法很少，也是些简单的方法，比如count()、index() count()用于统计某个元素在元组中出现的次数12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.count(1)) tup15.count(1)查询tup15里数值1出现的次数13 index()用于从元组中找出某个对象第一个匹配项的索引位置，如果不存在则报错12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.index(8)) tup15.index(8)查找数值8在元组tup15里第一个出现的索引位置12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.index(8)) 还可以指定开始到结束的下标，第二个是开始的下标位置，第三个是结束的下标位置，如果结束下标没写就默认是最后一个12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.index(1,1,7)) tup15.index(1,1,7)查询数值1在元组tup15下标1到下标6的索引位置15]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_04:python运算符]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-04-python%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[上一篇我们学习了3个基本类型，但是只是知道了这几个类型，还不知道到底能有什么，那么这篇我们就来学习运算符，把上一篇的知识融合进来。 运算符从字面上来理解就是运算的符号，就和在学校学的数学运算符一样，就是做运算用的，但是在编程语言里有一些是比较特别的，和平时的运算符有区别，那么废话不多说，来看看下面的结构图 从图片上可以看出，运算符分为7类，算术、比较、赋值、逻辑、位、成员和身份，这些我们都会在这篇文章里学到，大家不要被这看上去很多的样子所害怕，其实它们真的很简单，只要上过小学数学就完全可以学会 变量在正式讲运算符之前我们来引入一个新东西，它叫变量，变量是什么，可以简单的理解就是用来存储数据的，这么说有点抽象，那我们通过一个例子来理解。 例子现在假如家里有一推衣服和鞋子，两个收纳盒，把衣服和鞋子都按类放在收纳盒里，以便下次需要的时候方便找到。我们来分析这整个过程 首先我们要有两个收纳盒，为了方便辨别收纳盒里放的是什么我们给收纳盒贴个标签，分别命名为clothes和shoes。这个过程我们就可以认为是命名变量，因为变量可以有很多个，为了方便知道变量都是存的什么，我们可以给变量取一个名字。 既然收纳盒有了，也知道收纳盒里都放什么了，那我们旧把衣服放进标有衣服标签的收纳盒，鞋子放进标有鞋子标签的收纳盒。这个过程我们就可以认为是赋值给变量，既然有变量了，那总得存点什么数据，我们就可以赋值，叫变量赋值 这就是变量的作用和存储的过程，这里只是举了个简单的例子说明了变量，其实变量是很深奥的，如果真的把全部讲清，可能很多人都看不懂，目前我们知道会用变量就可以了，至于变量的存储内部到底怎么实现的，存的到底是不是就是我们赋值的，这个到以后在详细的探讨 命名变量变量的命名是有规定的。 变量名只能包含字母、数字、下划线，变量名可以以字母和下划线开头，但不能以数字开头。 比如：students，Teacher，_school，people5都是可以的 比如：5apple就是错的 变量名中不能有空格，可以用下划线代替。 比如：students_name是可以的 比如：teacher name，这样就是错的 不要用Python中的关键字作为变量名。 所谓的关键字就是python已经定义好的名字，这些名字是有意义的，我们就不能作为变量名了 比如：print就不能作为变量名，print有它的意义，他可以作为打印输出，如果你非要使用这个变量名可以用开头大写，python是区分大小写的，print和Print就不是同一个东西了 变量赋值变量赋值就是讲数据赋值给变量，可以使用=来赋值，比如：stu_name=”小明”,这就是赋值，很简单吧，并没什么难得，关于赋值我们会在下面更详细的讲解 算术运算符算术运算符就是做简单计算用的，加减乘除这些都在小学学过了，我就不废话了除了这几个外还有3个，分别是求余、整除和指数 求余就是将除法等到的余数部分提取出来，这个在一些场景下非常有用 整除正好相反，只提取整数部分 指数就是求次方，和小学的指数一样 我们用代码来体验一下12345678910111213141516a=10b=3c=a+bprint(&quot;a+b=&quot;,c)c=a-bprint(&quot;a-b=&quot;,c)c=a*bprint(&quot;a*b=&quot;,c)c=a/bprint(&quot;a/b=&quot;,c)c=a%bprint(&quot;a%b=&quot;,c)c=a//bprint(&quot;a//b=&quot;,c)c=a**bprint(&quot;a**b=&quot;,c) 输出的结果1234567a+b= 13a-b= 7a*b= 30a/b= 3.3333333333333335a%b= 1a//b= 3a**b= 1000 现在开始我们就会用上面讲到的变量了，这里声明了3个变量，分别是a，b和c，然后将10赋值给a，3赋值给b，而c的值就是a和b运算后的结果。在这要说一下，python是不需要声明变量的类型的，因为python会自动去识别。再看print也变得和以前稍微不同了，前面字符串很好理解，就不再说了，后面多了一个逗号，又一个变量名。逗号的作用就是分隔，表示前面和后面的不是一起的，需要分开，前一篇说过，只有字符串打印输出才要加引号，所以打印输出变量的时候，可以直接用变量名就可以输出变量的值 好了，回到我们的代码，前面加减乘除就不解释了，大家都懂的，说说后面3个 %：这是求余符号，10除3，商3余1，那么余数就是1，结果就是1 //：整除，和除法要区分开，除法是一个/，10除3，是3.3333333333333335，整数部分是3，那结果就是3 **：指数，也同样要和乘法区分开来，指数运算就没什么好说的了 最后我们来看看除法，按道理10除3结果是3.333333333333333…,无限循环3才对，怎么最后是5了呢？这是因为浮点数它在机器里是以十进制表示的方式是无限趋近于结果，会造成准确性下降，但这也只是最后几位的才会出现。这里要真的解释清楚不是一时半会的事，如果你有计算机基础或感兴趣的可以看看python官网给的解释 比较运算符顾名思义，就是比较时候用的运算符，基本上就是等于（==）、不等于（!=）、大于（&gt;），大于等（&gt;=）、小于（&lt;）、小于等于（&lt;=） 不等于，大于，大于等于，小于，小于等于大家一眼就能看出来，这里主要说说等于 等于是用两个等号来表示的，千万不要的赋值符号搞混了，这是很多初学者都会犯下的一个错误。比较运算得到的结果一般都是布尔类型的，要么是真，要么是假，不会出现其他的。123456789a=10b=3print(&quot;a&gt;b is&quot;,a&gt;b)print(&quot;b&gt;=a is&quot;,b&gt;=a)print(&quot;b&lt;a is&quot;,b&lt;a)print(&quot;a&lt;=b is&quot;,a&lt;=b)print(&quot;a==b is&quot;,a==b)print(&quot;a!=b is&quot;,a!=b) 这次我们并没有使用第三个变量来接收a和b运算后的结果，而是直接在print里写上运算，这是可以的，最后输出的结果为下图123456a&gt;b is Trueb&gt;=a is Falseb&lt;a is Truea&lt;=b is Falsea==b is Falsea!=b is True 比较运算符就完事啦，很简单有木有 赋值运算符赋值运算符在讲变量的时候就已经讲过一个赋值符号了，其是赋值运算符就这么一个，其它的都是和算数运算符组合起来，我们直接看代码12345678910111213141516171819num1=5num2=8print(&quot;num1=&quot;,num1)print(&quot;num2=&quot;,num2)num1+=num2print(&quot;num1+=num2的结果是&quot;,num1)num1-=num2print(&quot;num1-=num2的结果是&quot;,num1)num1*=num2print(&quot;num1*=num2的结果是&quot;,num1)num1/=num2print(&quot;num1/=num2的结果是&quot;,num1)num2%=num1print(&quot;num2%=num1的结果是&quot;,num2)num2//=num1print(&quot;num2//=num1的结果是&quot;,num2)num1**=num2print(&quot;num1**=num2的结果是&quot;,num1) 上面都用上了赋值运算符，我只讲一个+=，其它的都是同理，num1+=num2相当于num1=num1+num2，当然刚开始可能还不是很熟悉，也可以使用算术运算符，等熟练了再用赋值运算符也是完全可以，这个完全取决于个人123456789num1= 5num2= 8num1+=num2的结果是 13num1-=num2的结果是 5num1*=num2的结果是 40num1/=num2的结果是 5.0num2%=num1的结果是 3.0num2//=num1的结果是 0.0num1**=num2的结果是 1.0 来看看输出的结果，看上去感觉怪怪的，好像有几个不对啊，怎么计算不对呢，难道机器出问题了？答案当时不是啦，这些都是对的，我们一个一个来讲解 num1=5，num2=8这个没啥好说的，大家都会了 num1+=num2的结果是 13，前面也讲了，就是把左边的加上右边的再赋值给左边的，把数字代进去就是num1=5+8,结果13,没毛病 num1-=num2的结果是 5，按照前面说的做，num1=5-8，结果应该是-3啊，怎么是5了，回想下上一步，num1的结果是多少，是13，在运算num1-=num2的时候有对num1赋值过其他的值么？没有吧，那么num1现在就是13，现在把13代进去。num1=13-8，结果是5，对了吧 num1*=num2的结果是 40，这个刚好误打误撞，前面得到的num1是5，又和一开始赋的值一样了，所以结果就是40 num1/=num2的结果是 5.0，这个现在大家能看出来了吧，num1的值已经是40了，不再是5了 num2%=num1的结果是 3.0，同样的道理，num1是5，而num2我面前面都没赋值，只是一开始赋过值，但是没有变，所以num2依旧还是8，8%5，结果现在大家都会算了，是3 num2//=num1的结果是 0.0，这里num2在上一步已经赋值成3了，而num1上一步没赋值，还是num1/=num2的值，5。代进去算下，整数部分是0 num1**=num2的结果是 1.0，num2的值已经是0了，任何数的0次方都等于1 讲解完后，我们改下代码，把num1和num2在每次运算后的值都打印出来看看，对不对12345678910111213141516171819num1=5num2=8print(&quot;num1=&quot;,num1)print(&quot;num2=&quot;,num2)num1+=num2print(&quot;num1+=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1-=num2print(&quot;num1-=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1*=num2print(&quot;num1*=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1/=num2print(&quot;num1/=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num2%=num1print(&quot;num2%=num1的结果是&quot;,num2,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num2//=num1print(&quot;num2//=num1的结果是&quot;,num2,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1**=num2print(&quot;num1**=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2) 在这里print后面多了更多的逗号了，前面讲过它的作用，这里就不再重复了，现在我们就这样，到后面我们学习高级的打印输出，会比这种省事很多123456789num1= 5num2= 8num1+=num2的结果是 13 ,num1= 13 ,num2= 8num1-=num2的结果是 5 ,num1= 5 ,num2= 8num1*=num2的结果是 40 ,num1= 40 ,num2= 8num1/=num2的结果是 5.0 ,num1= 5.0 ,num2= 8num2%=num1的结果是 3.0 ,num1= 5.0 ,num2= 3.0num2//=num1的结果是 0.0 ,num1= 5.0 ,num2= 0.0num1**=num2的结果是 1.0 ,num1= 1.0 ,num2= 0.0 位运算符位运算符就是把数字看作二进制来进行计算的，把二进制的每一位做运算 进制我们在现实生活中经常使用十进制，从0到9，超过9后就进一位，变成10，这个大家都知道，在计算机里不仅仅只有十进制，还有二进制，八进制，十六进制，其中二进制用的是最多的，紧接着十六进制，八进制到用的比较少 二进制只有0和1，逢二进一，比如：1010，这就是个二进制，只是这样看和十进制一样，很难区分，所以我们可以加上前缀0b或者0B，完整的二进制表示方法0b1010或者0B1010 十六进制也是一样的，逢十六进一，从数字0到9，之后就是从字母a到f，比如：1f2b，十六进制用0x或者0X表示，0x1f2b或0X1f2b 八进制也一样，从数字0到8，逢八进一，比如：137，八进制用0o或者0O表示，0o1f2b或0O1f2b 注意：前缀的第一个都是数字0，后面的是字母，数字0和字母o长得很像，很容易搞错，这一点一定要仔细 还有一个就是进制之间的转换问题，这个大家可以看看这篇文章里面讲的很详细。 我们在看看在python里是如何讲各种进制输出的123456a=25print(&quot;a的十进制是&quot;,a)print(&quot;a的二进制是&quot;,bin(a))print(&quot;a的十六进制是&quot;,hex(a))print(&quot;a的八进制是&quot;,oct(a)) 十进制直接使用就可以了，可以用bin()来将十进制转换二进制，然后输出，同样的，十六进制用hex()，八进制用oct()1234a的十进制是 25a的二进制是 0b11001a的十六进制是 0x19a的八进制是 0o31 位运算回到我们的正题，位运算符，既然我们知道二进制怎么表示后，我们就可以正式的来认识位运算符了，位运算符是二进制每一位的运算，可以分为与(&amp;)、或(|)、异或(^)、非(~)、左移(&lt;&lt;)、右移(&gt;&gt;),要想记住他们的运算规则，只要记住下面表里的规则就可以了12345678910a=3b=6print(&quot;a=&quot;,bin(a),&quot;,b=&quot;,bin(b))print(&quot;a&amp;b=&quot;,a&amp;b)print(&quot;a|b=&quot;,a|b)print(&quot;a^b=&quot;,a^b)print(&quot;~a=&quot;,~a)print(&quot;b&gt;&gt;2=&quot;,b&gt;&gt;2)print(&quot;b&lt;&lt;2&quot;,b&lt;&lt;2) 1234567a= 0b11 ,b= 0b110a&amp;b= 2a|b= 7a^b= 5~a= -4b&gt;&gt;2= 1b&lt;&lt;2 24 根据上面的口诀，按照每一位进行运算 与（&amp;）：a是11，b是110，a差一位，就在高位补一个0，不影响结果，a变成011，好了，位数相同了，从低位开始，1和0，只有一个1得0，1和1，全1得1，0和1，只有一个1得0，最后结果就是010，去掉最高为没意义得0就成了10,十进制就是2 或（|），也同样得，只要有一个1就得1，结果是111，十进制就是7 异或（^）:不同得1，根据口诀得到得结果是101，十进制就是5 非（~）:这个就有点特殊了，先根据口诀，0和1颠倒，得到100，但前面为什么会出现符号呢，因为数值的存储和读取问题，可以看这篇文章。 右移（&gt;&gt;）：右移两位，去掉最低的两位就是变成了1，十进制也是1 左移（&lt;&lt;）:同理，左移2位丢弃高位，低位补0，但是高两位并不是就是11，应该把二进制补全成8位的二进制，00000110，最高为是0，去掉，最低补上0，变成00011000，十进制就是24 逻辑运算符逻辑运算符就是判断逻辑的，和位要区分开来，逻辑运算符有and、or、not，主要是做bool运算，同样也有口诀帮助大家记12345678print(&quot;True and False = &quot;,True and False)print(&quot;True and True = &quot;,True and True)print(&quot;True or False = &quot;,True or False)print(&quot;True or True = &quot;,False or False)print(&quot;not False = &quot;,not False)print(&quot;not True = &quot;,not True) 123456True and False = FalseTrue and True = TrueTrue or False = TrueFalse or False = Falsenot False = Truenot True = False 感觉跟位运算符差不多，只不过是换成了布尔值，这里稍微扩展下，凡是非0的数都是Ture，这也就是，数字也可做逻辑运算，布尔值也可以做算术运算12print(int(True))print(int(False)) int()表示将括号里的数据类型强制转换成整数类型1210 False的值为0，True的默认值是1，那我们来试试将数字转换成布尔类型12print(bool(0))print(bool(5)) bool()是将数据强制转换成布尔类型12FalseTrue 可以看到只要是0就是False，非0就是True 了解了这些我们来用bool做算术运算12print(True+True)print(False-True) 122-1 再来看看用数字做逻辑运算12345678print(&quot;1 and 0 = &quot;,1 and 0)print(&quot;3 and 7 = &quot;,3 and 7)print(&quot;8 or 0 = &quot;,8 or 0)print(&quot;0 or 0 = &quot;,0 or 0)print(&quot;not False = &quot;,not 0)print(&quot;not True = &quot;,not 16) 1234561 and 0 = 03 and 7 = 78 or 0 = 80 or 0 = 0not False = Truenot True = False 最后的not还是显示的布尔值，结果和用布尔值运算是一样的 成员运算符成员运算符就是在不在的关系，可以想象成有一个队伍，某人在不在这个队伍里，是不是这个队伍的成员。比如字符串abcdefg，问d在字符串里吗？，答案肯定是在的，用bool来表示结果就是True，如果不在，就用False。1234567s=&quot;我是一名新博客主&quot;print(&quot;博客两字在变量s里吗？答案是：&quot;,&quot;博客&quot;in s)print(&quot;Damo两字在变量s里吗？答案是：&quot;,&quot;Damo&quot;in s)print(&quot;博客两字在不变量s里吗？答案是：&quot;,&quot;博客&quot;not in s)print(&quot;Damo两字不在变量s里吗？答案是：&quot;,&quot;Damo&quot;not in s) 1234博客两字在变量s里吗？答案是： TrueDamo两字在变量s里吗？答案是： False博客两字在不变量s里吗？答案是： FalseDamo两字不在变量s里吗？答案是： True 可以看到，成员运算符在做判断的时候很有用 身份运算符身份运算符就是判断是不是的关系，就像身份证一样，唯一的标识，差一点都不对，也是用bool表示结果1234567s=&quot;1a2b&quot;print(&quot;1a2b和s一样吗？答案是：&quot;,&quot;1a2b&quot;is s)print(&quot;1a2c和s一样吗？答案是：&quot;,&quot;1a2c&quot;is s)print(&quot;1a3b和s不一样吗？答案是：&quot;,&quot;1a3b&quot;is not s)print(&quot;1a2b和s不一样吗？答案是：&quot;,&quot;1a2b&quot;is not s) 12341a2b和s一样吗？答案是： True1a2c和s一样吗？答案是： False1a3b和s不一样吗？答案是： True1a2b和s不一样吗？答案是： False is和==好了，所有的运算符都讲完了，在这最后讲讲is和==的区别，两个都是用来判断是否相同，但是两者的区别可大了 ==：等于号是用来做比较，也就是比较两个值是否相等，常常用来比较数值 is：is不仅仅要是值相同，而且内存中的地址也要相同 我们来重点说说is，is它判断两个东西。第一个是值必须相同123456a = 1b = 1c = 2print(a is b,b is c)print(id(a),id(b),id(c)) id()是输出括号里的内存地址12True False140715950072656 140715950072656 140715950072688 可以看到，值相同，地址相同，最后的结果才是True。这里的结果可能会和你们的不一样，这个每个人的电脑都会有不同的结果，主要是输出的3个值都是一样的就对了，如果这还不能看出区别，我们来看看下面的代码123456789&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 500&gt;&gt;&gt; a = 500&gt;&gt;&gt; print(a == b)True&gt;&gt;&gt; print(a is b)False&gt;&gt;&gt; print(id(a),id(b))2149012190704 2149011769232 这是在交互模式下运行的，只为了说明is，并不推荐用交互模式写程序，这是交互模式的一个很坑的问题，正好可以说明is。开启交互模式时，会为用户创建号小整数的内存地址，所以超过这个范围的时候，两个变量就会指向不同的内存地址。 现在应该能看出is的和==的区别了，虽然值都相同，但时内存地址不用，对于is来说就是不同，所以时False 这一篇全部讲完了，内容稍微有点多，都是要记的，还是希望大家能多加练习，那么我们下一篇再聊吧]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_03:python基本数据类型]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-03-python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这一篇我们来学习python的基本数据类型，这也是学任何编程语言都必须掌握的一个很重要的东西。 python文件创建在正式讲数据类型前我们现在说下前面没有提到的一个东西，就是python文件，我们的所有代码都会写在一个文件里，这样可以保存下来，在下次用的时候可以直接使用，或者直接修改。所有的python文件都是以.py结尾的，如果是手动创建文件的话，要记得把后缀改成.py，如果是用IDE的话，可以直接创建python文件，不会的话可以百度下自己使用的IDE如何创建python文件。 python输出和基本格式我们在上一篇文章中在交互模式中输入了print(“Hello python!”)，这就是最简单的输出，print是打印的意思，告诉输出器，将括号里的内容打印到显示器上，所以按下回车后我们能看到立马打印出了Hello python!。我们可以用print打印任何内容，比如数字，单词，汉字，符号等等，也可以将这些混合输出。1234&gt;&gt;&gt; print(&quot;你好&quot;)你好&gt;&gt;&gt; print(&quot;今天是1月30日，I Love Python！&quot;)今天是1月30日，I Love Python！ 可能有些小伙伴想在打印出双引号，可是在当按下回车的时候报错了。12345&gt;&gt;&gt; print(&quot; &quot;我就是我，不一样的烟火&quot; &quot;) File &quot;&lt;stdin&gt;&quot;, line 1 print(&quot; &quot;我就是我，不一样的烟火&quot; &quot;) ^SyntaxError: invalid character in identifier 这是你们以后可能会经常遇到的错误，SyntaxError: invalid character in identifie的意思是语法错误：标识符中的字符无效，为什么会这样的，明明和以前的输入没什么区别，却报错了，原因很简单，就是因为print识别你所输入的内用是靠一对双引号来识别的，它识别一对双引号之间的内容，“ “我就是我，不一样的烟火” “，可以看到这句里有两对双引号，前面一对，后面一对，中间的并没有双引号，print不知道你输入的是什么东西，所以它就报错了，告诉你语法错误，可是我就想输出双引号怎么办，很简单，只要在要输出的双引号前加上\即可12&gt;&gt;&gt; print(&quot; \&quot;我就是我，不一样的烟火\&quot; &quot;) &quot;我就是我，不一样的烟火&quot; 这样我们就可以输出双引号了，先不用知道\是干嘛用的，知道可以输出双引号即可 重点！ python是区分大小写的，如果你输入的大小写不正确的话，得到的结果也会不一样 在python里所有的符号都必须是英文下的符号，如果用中文符号的话就会报错，这也是很多初学者很容易犯的一个错误 python的每一句末尾不需要加上;，因为在python里，一行就是一句代码。如果你想加上也是可以的，不会对程序有任何影响，但是如果一行里有多句代码的时候，就会报错，所以请一行就是一句代码 基本数据类型python的数据类型有许多，但是基本类型有8种，可以按照可不可变分为两大类。 不可变类型：就是这些类型的值是不可以改变，不可变类型又可以分为5种，分别是数字（number）、字符串（string）、布尔（bool）、元组(tuple)、None 可变类型：就是这些类型的值是可以改变的，可变类型又可以分为列表（list）、字典（dictionary）、集合（set） 这些基本的的数据类型在将来我们会经常用到，整个结构可以看下面的图片 在这篇中我不会把所有的类型都讲解一遍，先讲数字、字符串和布尔，其他在后面再讲，刚开始我们用不到那么多，有数字、字符串和布尔就够用了。 数字（Number）数字很容易理解，就是我们平时用的数字，比如1，3.1415926，这些都是数字，但是在python里面数字又分为整型和浮点型下面我们就来对这两种类型做详细的探讨 整型（int）整形就是数字的整数部分，也就说小数点左边的部分，整型很简单。在python里整形用int来表示，在python3里int的范围是很大的，也就是这个数字可以很大，能大到多少，我也不记得，反正是够我们用，我们可以通过print打印输出一下123456&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print(10)10&gt;&gt;&gt; print(123456789012345678901234567890)123456789012345678901234567890 在这里可以看到输入的数字是多少，输出就是多少，细心的小伙伴可能发现了，在这里并没有加双引号，这是因为输入的是数字，而不是字符串，python是能直接识别出来的，所以不用加上双引号，这个双引号的问题会在这篇最后和大家详细探讨，到底什么时候要加双引号 浮点型（float）浮点型其实就是我们平常所说的小数，带小数点的数，作者第一次接触浮点数时还以为是会浮起来的数，还满怀好奇心，得知后才发现自己多幼稚，好了，回到正题上，浮点数只要直接输入就可以了1234&gt;&gt;&gt; print(1.23)1.23&gt;&gt;&gt; print(456.321)456.321 字符串（string）可以简单理解为就是字符、文字、符号，通常是用引号引起来的，python是个非常人性化的，字符串不管你是用单引号，双引号，三引号，他都会认为这就是字符串，不像其他语言，双引号是字符串，单引号是字符，python统统认为是字符串，即使你引号里只有一个字符，它也认为是个字符串。 单引号和双引号单引号，用单引号引起来的的字符串，其实和双引号没什么区别，但是为什么还要区分单引号和双引号，原因很简单，你可试想下如果我要用单引号输出i’m a good boy,该怎么输出，只要输入python(‘i\’m a good boy’)12&gt;&gt;&gt; print(&apos;I\&apos;a a good boy&apos;)I&apos;a a good boy 我们可以直接使用\将单引号输出，这样还是看不出单引号到底有什么用，那么我们输出这句呢？We all know that ‘A’ and ‘B’ are two capital letters.12&gt;&gt;&gt; print(&apos;We all know that \&apos;A\&apos; and \&apos;B\&apos; are two capital letters.&apos;)We all know that &apos;A&apos; and &apos;B&apos; are two capital letters. 可以看到多好几个单引号，每个前面都要用\，很麻烦，可读性太差了，所以这时候我们可以用双引号来表示字符串，这样在双引号里的单引号就不用加\了12&gt;&gt;&gt; print(&quot;We all know that &apos;A&apos; and &apos;B&apos; are two capital letters.&quot;)We all know that &apos;A&apos; and &apos;B&apos; are two capital letters. 同样的道理，如果带双引号的字符串里也有双引号的话，我们就可以用单引号在表示字符串。12&gt;&gt;&gt; print(&apos;The teacher said: &quot;Practice makes perfect&quot; is a very famous proverb.&apos;)The teacher said: &quot;Practice makes perfect&quot; is a very famous proverb. 现在知道为什么会有单引号和双引号了吧，就是为了方便我们在不同的字符下能很好的把引号输出来，增强代码的可读性 到这里，有小伙伴就想到了很绝的问题，那我字符串里又有单引号又有双引号怎么办？那么接下来的三引号完美解决这个问题 三引号前面我们知道了单引号和双引号的区别后，留下了一个大问题，就是字符串里又有单引号又有双引号。我们先来把这个问题解决了，用法和前面的一样，只是字符串换成了三个单引号组成三引号而已12&gt;&gt;&gt; print(&apos;&apos;&apos;父亲对小明说:&quot;咱们这地方出产的&apos;龙井&apos;可是上等好茶，明天你带上几斤去探望你们的老师。&quot;&apos;&apos;&apos;)父亲对小明说:&quot;咱们这地方出产的&apos;龙井&apos;可是上等好茶，明天你带上几斤去探望你们的老师。&quot; 好了这个问题轻松解决，我们再回到三引号的问题上，其实三引号不单单只是为了方便输出单引号和双引号，它最大的用处在于，它可以在你一行内容太多的时候换行继续写，前面也介绍了python一行就是一句代码，但是有时候字符串特别长，为了可读性我们可以换行写。12345678&gt;&gt;&gt; print(&apos;&apos;&apos;aaaaaaaaaaaaaaaaaaaaaaaa... bbbbbbbbbbbbbb... cccccccccccccccc... dddddddddddd&apos;&apos;&apos;)aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbccccccccccccccccdddddddddddd 这里我说明下，如果在交互模式换行后会出现三个点，表示等待用户继续输入的意思，直到完成一句完整的代码，回车才会执行。 布尔型（bool）布尔类型的值只有2个，分别是True和False，从单词上就能看出，一个表示真，一个表示假，没错，布尔类型就是表示真和假这么简单，我们打印输出一下1234&gt;&gt;&gt; print(True)True&gt;&gt;&gt; print(False)False type()现在我们回到一开始遗留下来的问题，print里到底什么时候要加双引号，其实这个就是关系到数据类型的问题，现在我们学了三种数据类型，数字、字符串和布尔，当我们输出字符串的时候都带有引号，而数字和布尔时并没有加，所以可以看出，凡是带有引号的都是字符串，理解这一点后我们来看看下面的两句输出1234&gt;&gt;&gt; print(&quot;1&quot;)1&gt;&gt;&gt; print(1)1 这两句都是输出1，结果乍一看没什么区别，其实它们有着很大的区别，先来回想一下刚才所说的，凡是带有引号的都是字符串，那么很容易看出第一句输出的是字符1，而第二句输出的是数字1。光说没什么用，那我们就来验证一下对不对，在这里我们再学一个新函数(函数是什么后面会讲解到)，type(),这个函数可以输出括号里输入的类型，那么我们来验证下刚才问题1234&gt;&gt;&gt; print(type(&quot;1&quot;))&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; print(type(1))&lt;class &apos;int&apos;&gt; type(“1”)把”1”输入到type函数里，然后type输出了类型，但是没法打印出来，所以我们外面再套一层print，这样我们就可以在显示器上看到输出的结果 我们可以看到两句输出的类型都不一样，&lt;class ‘str’>，class表示类（后面将会学到类），紧接着是str，这是字符串的string的缩写，可以看出这句的类型是字符串，下面那一句也是一样，但是输出的是int，这是整数类型，现在应该知道什么时候用引号了，既然我们用了type()了，那我们来验证下浮点型的数字和布尔类型123456&gt;&gt;&gt; print(type(1.23456))&lt;class &apos;float&apos;&gt;&gt;&gt;&gt; print(type(True))&lt;class &apos;bool&apos;&gt;&gt;&gt;&gt; print(type(False))&lt;class &apos;bool&apos;&gt; 嗯，验证后没问题，这就是浮点型(float)和布尔类型（bool） 好了，这篇就到这里了，内容不是特别多，都是写记忆性的东西，代码还是希望大家多敲。下一篇我们将学习运算符。那么我们下一篇见]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_02:python安装]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-02-python%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这一篇将教大家如何在linux和window平台下载及安装python，还会推荐几个本人用过的IDE，希望能帮助大家快速在自己点电脑搭建好环境 window用户window安装python需要到官网下载安装包进行安装。 下载python首先我们打开浏览器，在网址栏里输入https://www.python.org/，或者在百度里搜索python找到官网。 进入官网后点击导航栏的Downloads跳转到下载页面 跳转到下载页面后会自动检测你当前浏览官网的操作系统是什么，如果你是window操作系统，会显示Download the latest version for Windows，核对操作系统无误后就点击文字下方的Download Python 3.7.2进行下载。如果显示的不对就在在红框中选择自己电脑的操作系统 安装下载好安装包后，双击安装包 进入安装界面我们选择自定义安装，下面两个勾一定要打上，特别是第二个添加环境变量，打勾后在后面就可以省略配置环境的步骤，如果忘了打勾耶没关系，后面教大家如何手动添加环境变量 这里没什么好说的，能打勾都打上，然后我们点击Next进行下一步 在这里请把1、2、3、4、5项打上勾，然后可以将安装路径改为自己想安装的地方，不建议大家安装到系统盘里，然后点Install开始安装如果出现了下图红框里的setup was successful表示安装完成了，点击Close 配置环境变量如果你在安装的时候将环境变量的选项打勾了的话，可以跳过这一步，如果你忘了打勾，没关系，我们手动配置即可 首先我右击我的电脑选择属性 然后我们选择高级系统设置 然后再选择环境变量 找到系统变量，选中Path这一项，然后再选择编辑 再编辑环境变量界面里将python目录下的Scripts目录添加进去即可的 测试同时按下win键和R键，然后输入cmd，回车打开doc（命令提示符） 然后输入下面的指令(注意，V是大写的)1python -V 如果没有显示任何错误且显示了python和对应的版本则说明安装成功了! Linux用户如果你是Linux用户的话，那就很轻松了，一般Linux是自带python，而且版本还是比较新的，打开Linux终端输入python3 -V（Linux下的python是区分2和3的，如果是2的话，只要输入python即可，3的话要输入python3）123zs@zs:~$ python3 -VPython 3.5.2zs@zs:~$ 如果已经安装效果会和window一样，显示python和对应的版本，如果没有的话或者没有python3的版本我们就自己安装一个，在这里我只以Ubuntu为例，其他的也是类似的，可以再网上找到对应教程，我们在终端输入sudo apt-get install python3,然后会出现提示说是否继续，输入y回车继续，然后静静的等待安装完成即可，完成后我们输入python3 -V检测是否成功。Linux下的python3就已经安装完成了。 Mac用户如果你是Mac用户的话，一般情况也是自带，这里因为我没有Mac系统的电脑，所以这里将无法演示，但是安装的步骤基本上和window一样。如果实在不会，可以看看这篇文章(mac安装python)，里面讲解了Mac下如何安装python3 python的交互模式通过上面的方法我们完成了python3的安装，接下来我们来说python3的交互模式。 可以简单的理解为人机交互，就是我输入一些东西，立马就会得到输出的结果。这样的好处在于，需要做简单的代码测试的时候，可以很快的得到结果，但是，这样是有缺点的，就是代码量不能太多，一旦代码量多的话就会出现自己都不记得自己前面写的代码是什么，可读性很差。 接下来我们来启动python3的交互模式，无论是什么操作系统下的python，启动方法都是一样的，我们打开终端输入python(在这里说明一下：如果你的电脑装有多个版本的python，你可以输入python后面加上你要启动的版本号即可开启你想要的版本，Linux下是自带python的，2和3都有，可以输入python3开启交互模式**)1234C:\Windows\system32&gt;pythonPython 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 这样我们就开启了交互模式，我们可以看到，已开启可以看到python的版本和一些其他的信息，最下面有一个&gt;&gt;&gt;符号，这是说明等待用户输入的意思，我们现在来输入一句简单代码，现在还不用知道是什么意思，这些代码再后面会讲到。好了，我们输入print(“Hello python!”)123456C:\Windows\system32&gt;pythonPython 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; print(&quot;Hello python!&quot;)Hello python!&gt;&gt;&gt; 当我们输入完print(“Hello python!”)后，按下回车，电脑立马就给我们输出了Hello python!，然后下面又出现了&gt;&gt;&gt;的符号，这就是python的交互模式。输入exit()即可退出交互模式 但是，我们是要写程序的，代码量不可能就这么几句，所以我们这下来选一个自己顺手的IDE（集成开发环境），这样可以提高我们大代码编写速度和可读性 IDE个人推荐现在网上有很多的ID，都各有千秋，所以这里我就不去介绍这些IDE了，我只对我用过的IDE做简单介绍，推荐几款我用的比较顺手的IDE给大家 pycharmpycharm是为python专门打造的IDE，功能非常强大，但是这款IDE很大，启动速度会比较慢，基本上在大公司里都会用这款IDE去开发python的程序，如果感兴趣的话可以去pycharm官网看看,安装教程的话现在网上一大把，随便百度下就有了，还有，这款IDE需要破解才能发挥出它的强大之处，至于怎么破解，甩锅给百度就好了，我就不说了。。。 sublime textsublime text是一款集合了目前为止比较流行的编程语言的IDE，不仅可以用来编写python，还可用来编写java，c，c++，c#，html等等，体积不大，启动速度是我用过最快的一款，但是它没有pycharm那样强大，很多强大的功能需要自己去安装插件，可是插件的安装对新手来说很不友好，安装方法很麻烦，还不稳定，不知道是不是我的方法有问题，反正，这款IDE非常适合有一定经验的人使用。sublime text官网,安装方法和后续的找度娘 atomAtom是github开发的，专门为程序员开发的一款IDE，同样小巧，启动速度的话会比sublime text慢一些，同样需要安装插件来增强atom，它的插件安装可就简单多了，在IDE里直接搜索你想要的插件，下载就可以安装好了，这也是我用的最舒服的一款，同样可以编写大部分的编程语言，而且这款IDE火起来的原因是，你在敲代码的时候，会有抖动的动态效果，非常震撼，但是没什么卵用，只能无聊时装X，atom官网，安装方法的话百度也有，这里就不做过多的介绍了。 vim有用过Linux的用户看到vim肯定会疑惑，我为什么会推荐vim，对，vim不属于IDE，而且window很少人回去用，但是我还是要推荐它，Linux可不像window一样，有很多都用不了，所以我推荐了一款Linux下的编辑器，运行速度没得说，一个字！快。。。功能的话，这只是的编辑器，就我们常用的文本编辑器一样，不要急，它不是一无用处，它也可能打造成IDE，功能的话还行，当年我在Linux编写程序的时候就是用vim，安装各种插件，把编辑器变成了一个简单的IDE，用久了还觉得很舒服。 总结最后是总结下推荐的这4款IDE，如果你是window用户的话，电脑也比较牛的话推荐用pycharm，简单又强大，如果电脑配置没那么好的，可以试试sublime text或者atom，这两款都差不多，哪个顺手用哪个。如果是Linux用户的，前面几个也是可以的，但是安装起来就会比较麻烦，如果不想麻烦的话，可以尝试下vim。当然这里推荐的都觉得不合适的话，可以自己去百度查找一款合适自己的IDE，这是完全没问题的，毕竟IDE只是一个工具，提高我们开发的速度和可读性，完全没比较纠结功能强不强大，只要自己用的顺手就好 好了，这篇就到这里结束了，现在我们安装好了python，也安装好了IDE，接下来我们就可以正式的开始进入python的大门了，从下一篇开始就开始学习python的一些基础知识了，这里我想和大家说 代码只看没什么用，它不认识你，只有多敲代码，这样才能提高自己]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_01:python简介]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-01-python%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Python是一种计算机程序设计语言。是一种动态的、面向对象的脚本语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 python的起源Python是由一位Guido von Rossum叫荷兰人创造，俗称龟叔。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。 在那个时候，他接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 然而，这种思考方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间 (即使他已经准确的知道了如何实现)。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器(interpreter)已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词(word)的总数：(以下代码没必要懂，了解即可)1234567HOW TO RETURN words document: PUT &#123;&#125; IN collection FOR line IN document: FOR word IN split line: IF word not.in collection: INSERT word IN collection RETURN collection HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号(:)和缩进来表示程序块(C语言使用{}来表示程序块)。行尾没有分号。for和if结构中也没有括号()。如果将HOW TO改为def，将PUT行改为collection = []，将INSERT行改为collection.append(word)，这就几乎是一个标准的Python函数。上面的函数读起来就像一段自然的文字。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。 python的诞生1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森干的飞行马戏团》（Monty Python’s Flying Circus）。 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。 最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。 python的应用好了，上面讲了那么多，现在我们来看看我们学的python到底能做什么？ 目前Python主要应用领域 云计算: 云计算最火的语言， 典型应用OpenStack WEB开发: 众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣。。。， 典型WEB框架有Django 科学运算、人工智能: 典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas 系统运维: 运维人员必备语言 金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java,尤其擅长策略回测 图形GUI: PyQT, WxPython,TkInter Python在一些公司的应用 谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发CIA: 美国中情局网站就是用Python开发的NASA: 美国航天局(NASA)大量使用Python进行数据分析和运算 YouTube:世界上最大的视频网站YouTube就是用Python开发的 Dropbox:美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载 Instagram:美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发 Facebook:大量的基础库均通过Python实现的: 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的 豆瓣: 公司几乎所有的业务均是通过Python开发的 知乎: 国内最大的问答社区，通过Python开发(国外Quora) 春雨医生：国内知名的在线医疗网站是用Python开发的除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。 看完上面的介绍后是不是觉得python非常的厉害，各大公司都在应用python做开发，小到简单的模块功能，大到科学运算、人工智能、数据分析，无所不能一样，但是很遗憾，每种编程语言都有各自的优缺点，这是无法避免的，那接下来就看看python都有什么优缺点，可以快速的决定python是否适合自己使用 Python的优缺点先看优点: Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。 高级语言——当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性——由于它的开源本质，Python以及被移植到许多平台上（经过改动使它能够工作在不同平台上）。如果你小心的避免使用依赖于系统的特性，那么你的Python程序无需修改就几乎可以在市场上所有的系统平台上运行。 可扩展性——如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 可嵌入性——你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚步功能。 再看缺点： 速度慢，Python的运行速度相比C语言确实慢很多，跟Java相比也要慢一些，因此这是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来！ 代码不能加密，因为Python是解释性语言，它的源码都是以明文形式存放的，不过我不认为这算是一个缺点，如果你的项目源代码必须是加密的，那你一开始就不应该用Python来去实现。 线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在windows上为Win thread，完全由操作系统调度线程的执行。一个Python解释器进程内有一条主线路，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。 选python2还是python3了解完python的优缺点后，我们来了解下python现在的版本问题，到目前为止python官网出了两个版本，一个是python2，另一个是python3，而且这两个版本并不兼容，这也就意味着，如果你学的是python2，那么有些东西在python3是无法使用的，而且官网也明确说了，python2将不再维护更新，建议使用python3，所以这个问题，很明确，我们现在应该选择python3。 好了，关于python的介绍就到此为止了，虽然这些不需要我们记下来，但是，既然以后要开始学习python，起码应该了解python的一些课外内容，在下一篇文章，我们将学习如何安装python和编写我们的一个程序。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[在写这篇文章的时候，我一直在想，我作为一名博客新人到底第一篇应该写点什么？因为本人也不是什么大神，我也很害怕自己写的不好，甚至害怕会误人子弟，所以我选择了第一篇就以python3为开端，虽然现在网上有许多的python的教程，也有很多的大神的文章，那么有人就会问了，“既然网上有那么多的python的教程了，为什么我还要写这种教程”，这个问题我也想过，大神的很多文章写的都很详细，而且他们的经验都比较丰富，但是有些教程时间很长了，有些东西已经过时了，或者有更加简单的方法，如果大家都还在看着过旧的教程，难免会造成误导，所以我写了一个python的教程系列，希望想学python的朋友能少走一些弯路。 前言本来打算将python的教程全部写在这篇文章里，后来想了下，如果全部写在一片文章里可能会造成文章的篇幅太大，而且不易分类和快速查找，所以我将这篇文章作为目录。 目录 python3从零开始_01:python简介 python3从零开始_02:python安装 python3从零开始_03:python基本数据类型 python3从零开始_04:python运算符 python3从零开始_05:元组 python3从零开始_06:列表 python3从零开始_07:字典 python3从零开始_08:集合 python3从零开始_09:补充与提高 python3从零开始_10:条件控制语句 python3从零开始_11:循环控制语句]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
</search>
