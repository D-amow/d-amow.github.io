<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python3从零开始_06:列表]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-06-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[我们上一篇学完了元组，这一篇马上进入列表的学习中，因为列表和元组非常相似，我们趁热打铁，只要懂了元组，列表也就很简单了 列表是属于可变数据结构，它与元组很相似，唯一的区别就是，数据可变，其他的基本上都一样，操作也是，所以这一篇讲的会比较快 增首先我们同样先学习创建列表，列表的创建和元组一样，但是列表用[]括起来，而不是用()，这点需要大家留意12345678910lis1 = [1,2,3]lis2 = [&quot;I&quot;,&quot;Love&quot;,&quot;Python&quot;]lis3 = [False,True]lis4 = [1,&quot;python&quot;,True,(20,30),[&apos;a&apos;,&apos;b&apos;]]lis5 = [&apos;a&apos;]print(&quot;lis1=&quot;,lis1)print(&quot;lis2=&quot;,lis2)print(&quot;lis3=&quot;,lis3)print(&quot;lis4=&quot;,lis4)print(&quot;lis5=&quot;,lis5) 创建的操作和元组一模一样，只是括号变了，多个元素依然用逗号隔开，同样可以是多种类型的元素，也可以嵌套，如果元组都懂，这个完全没难度了,在列表了，如果是由一个元素时，可以不再用逗号去强调，只要和平时使用的方法使用就可以了12345lis1= [1, 2, 3]lis2= [&apos;I&apos;, &apos;Love&apos;, &apos;Python&apos;]lis3= [False, True]lis4= [1, &apos;python&apos;, True, (20, 30), [&apos;a&apos;, &apos;b&apos;]]lis5= [&apos;a&apos;] 输出也是一样，为了方便区分，同样用[]表示，省去了type()的时间。 删删除也是一样，使用del可以将整个变量删掉，但是，列表时可变数据结构，那它就可以修改列表里的元素，这也就是意味着可以只针对某个元素做操作，比如删除列表里某个元素12345lis6 = [1,2,3]print(lis6)print(&apos;-----------------&apos;)del lis6print(lis6) 这里删除整个就不多说了123456[1, 2, 3]-----------------Traceback (most recent call last): File &quot;.\a.py&quot;, line 11, in &lt;module&gt; print(lis6)NameError: name &apos;lis6&apos; is not defined 我们回顾下上一篇里的元素下标，每个元素都有一个下标号，从左往右是从0开始，从右往左是从-1开始，索引用[]，切片只需要在[]里加:，左边是开始的下标，右边是结束的下标减1，如果再加个:就表示步数，可以跳跃。 好了，这些想起来就会容易很多，从下面开始，基本上就是这些操作了。12345678910111213141516lis7 = [1,2,3,4,5,6,7,8]print(lis7)del lis7[2]print(lis7)print(&apos;-----------------&apos;)lis8 = [1,2,3,4,5,6,7,8]print(lis8)del lis8[2:5]print(lis8)print(&apos;-----------------&apos;)lis9 = [1,2,3,4,5,6,7,8]print(lis9)del lis9[::2]print(lis9) 可以看到lis7是通过索引删除指定下标的元素，lis8通过切片，而lis9还怎加的步数，这些操作是不是和元组一样，所以元组那一篇搞懂了，这就很简单了12345678[1, 2, 3, 4, 5, 6, 7, 8][1, 2, 4, 5, 6, 7, 8]-----------------[1, 2, 3, 4, 5, 6, 7, 8][1, 2, 6, 7, 8]-----------------[1, 2, 3, 4, 5, 6, 7, 8][2, 4, 6, 8] 查查就通过下标索引，切片和，这些都是讲过的，只不过把元组换成了列表1234lis10 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;]print(lis10)print(lis10[-7:-2])print(lis10[1:8:3]) 操作上基本都没什么难度了，再以前看来很难得现在变得很简单了。123[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;][&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;][&apos;b&apos;, &apos;e&apos;, &apos;h&apos;] 这里就不再玩作死了…现在来说都不是作死了，都已经没挑战性了。有兴趣得话，大家可以自己去尝试下 改因为列表是可变的，所以可以修改元素，而修改元素说白了就是用下标查找到该元素，然后从新赋值，就这么简单1234567891011121314lis11 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]print(&quot;lis11修改前：&quot;,lis11)lis11[1] = 1print(&quot;lis11修改后：&quot;,lis11)lis12 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]print(&quot;lis12修改前：&quot;,lis12)lis12[2:4] = &quot;hi&quot;,&quot;python&quot;print(&quot;lis12修改后：&quot;,lis12)lis13 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]print(&quot;lis13修改前：&quot;,lis13)lis13[::3] = 2,3print(&quot;lis13修改后：&quot;,lis13) 这里有一点需要注意得，就是你要修改多少元素就要赋值多少个元素，否则就是报错，这点大家要注意，一般很少范围性得修改，修改单个比较多。123456lis11修改前： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]lis11修改后： [&apos;a&apos;, 1, &apos;c&apos;, &apos;d&apos;]lis12修改前： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]lis12修改后： [&apos;a&apos;, &apos;b&apos;, &apos;hi&apos;, &apos;python&apos;, &apos;e&apos;, &apos;f&apos;]lis13修改前： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]lis13修改后： [2, &apos;b&apos;, &apos;c&apos;, 3, &apos;e&apos;] 运算说到运算就想到了元组的+，*，in，同样在列表也是一样，而且效果也是一样的1234567lis14 = [1,2]lis15 = [4,5]lis16 = lis14+lis15lis17 = lis14*3print(lis16)print(lis17)print(4 in lis15) 123[1, 2, 4, 5][1, 2, 1, 2, 1, 2]True 方法最后说说列表的方法，因为是可变的数据结构，所以方法会比元组多，而且都很实用 count()统计某个元素在列表中出现的次数12lis18 = [1,2,3,1,1,2,4,5]print(lis18.count(1)) 13 index()从列表中找出某个值第一个匹配项的索引位置12lis18 = [1,2,3,1,1,2,4,5]print(lis18.index(2)) 11 可以指定开始到结束的下标 12lis18 = [1,2,3,1,1,2,4,5]print(lis18.index(1,2,5)) 13 clear()清空列表12lis18 = [1,2,3,1,1,2,4,5]print(lis18.clear()) 1None None就表示空的意思，什么都没有，None也是一个数据类型，只有唯一的值，就是None append()在列表末尾添加新的对象123lis18 = [1,2,3,1,1,2,4,5]lis18.append(&apos;a&apos;)print(lis18) 1[1, 2, 3, 1, 1, 2, 4, 5, &apos;a&apos;] 这个方法需要注意一下，append()是没有返回值的。如果你print(lis18.append(‘a’))结果是None，因为没有返回的结果。如果用另外的变量去接收也是一样没效果，所以append只是自己末尾添加后，仍然将数据存在自己 pop()移除列表中的一个元素（默认最后一个元素），并且返回该元素的值123lis18 = [1,2,3,1,1,2,4,5]print(lis18.pop())print(lis18) 125[1, 2, 3, 1, 1, 2, 4] 同样可以指定下标123lis18 = [1,2,3,1,1,2,4,5]print(lis18.pop(1))print(lis18) 122[1, 3, 1, 1, 2, 4, 5] sort()对原列表进行排序123lis18 = [1,2,3,1,1,2,4,5]lis18.sort()print(lis18) 1[1, 1, 1, 2, 2, 3, 4, 5] 和append一样没有返回值 reverse()反向列表中元素123lis18 = [1,2,3,1,1,2,4,5]lis18.reverse()print(lis18) 1[5, 4, 2, 1, 1, 3, 2, 1] remove()移除列表中某个值的第一个匹配项123lis18 = [1,2,3,1,1,2,4,5]lis18.remove(2)print(lis18) 1[1, 3, 1, 1, 2, 4, 5] extend()在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）1234lis18 = [1,2,3,1,1,2,4,5]lis19 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]lis18.extend(lis19)print(lis18) 1[1, 2, 3, 1, 1, 2, 4, 5, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] insert()将对象插入列表123lis18 = [1,2,3,1,1,2,4,5]lis18.insert(2,&apos;ccc&apos;)print(lis18) 1[1, 2, &apos;ccc&apos;, 3, 1, 1, 2, 4, 5] 逗号后面表示插入的数据，逗号前面表示数据插入的下标号 copy()复制列表123lis18 = [1,2,3,1,1,2,4,5]lis19 = lis18.copy()print(lis19) 1[1, 2, 3, 1, 1, 2, 4, 5]]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_05:元组]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-05-%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这篇我们单独来讲讲python中元组,元组是属于不可变数据结构，这却成为了python的标准数据结构，这里面也肯定有它优越之处，那么我们就来学习下元组这个数据结构 在前面数据结构那篇我们介绍到数据结构可以分为可变和不可变，元组就是不可变的数据结构之一，也就是说如果我们定义了一个元组类型的数据结构，那么它里面的数据是不可再做修改，正因为这种特性，往往将一些安全系数较高的数据都会定义成元组，这样可以防止在做数据操作的时候误把数据的原值破坏掉，所以元组的操作很简单，可以分为创建、删除、访问、索引、切片还有一些简单的内置方法，接下来我们一个一个来说 元组的创建与删除创建创建元组和创建其他数据类型一样，但是要注意的是，创建元组的时候必须将数据用小括号括起来，这样表明这个数据是元组类型，在括号里可以有多个数据，可以是不同类型的数据，我们目前学了数值、字符串和布尔类型，那么我们来来尝试创建这三种类型的元组。还有在创建多个数据的时候用逗号隔开。 1234567tup1 = (1,2,3)tup2 = (&quot;I&quot;,&quot;Love&quot;,&quot;Python&quot;)tup3 = (False,True)print(&quot;tup1=&quot;,tup1)print(&quot;tup2=&quot;,tup2)print(&quot;tup3=&quot;,tup3) 这里分别创建了3个元组，里面的值分别是数值、字符串和布尔类型，通过用逗号将多个值隔开，并且都用小括号括起来，这就是元组的创建123tup1= (1, 2, 3)tup2= (&apos;I&apos;, &apos;Love&apos;, &apos;Python&apos;)tup3= (False, True) 通过输出也可以看到，输出变量的值也是括号括起来的，这样可以一眼就看出，这个变量是元组类型的，这也方便了我们直接查看数据的类型，不用每次都用type()去查看 既然我们能创建元组了，里面的值类型而且还可以是其他类型的，那我们来混合这些类型试下12tup4 = (1,&quot;python&quot;,True,(20,30))print(&quot;tup4=&quot;,tup4) 可以看到，我们混合了类型也是可以的，而且在元组里面还创建元组类型的值，这就是嵌套，这也是允许的，在后面会讲到的列表、字典、集合都是一样的1tup4= (1, &apos;python&apos;, True, (20, 30)) 输出的结果也是一样，括号括起来的，在里面的元组也是一样，这里就没什么好说的了，接下来说当创建元组是，只有一个值的时候的问题，这也是初学者出错比较多的比方 我面前面已经知道创建元组要用括号括起来，多个值的时候用逗号隔开，那我创建一个是不是就不用逗号了呢？这个问题我们看下面的代码来解释123456tup5 = (1)print(&quot;tup5=&quot;,tup5)print(type(tup5))tup6 = (1,)print(&quot;tup6=&quot;,tup6)print(type(tup6)) 我们先来思考一个问题，括号在不同的地方有着不同的作用，比如在数学中，括号表示优先运算的意思，在元组中表示是元组类型，机器不像人类一样会思考，在机器里括号就是一个符号，那我用括号括起来一个数字，你说他是数值类型还是元组类型，恐怕你自己都很难说清楚，更何况机器了，所以python想了一个办法，就是元组只有一个值的时候用逗号区分，我们从代码里已经看到了，创建一个值得时候依然用了逗号，这样告诉机器，我这是元组，别把它当成是数值啦。1234tup5= 1&lt;class &apos;int&apos;&gt;tup6= (1,)&lt;class &apos;tuple&apos;&gt; 通过结果能很明显得看到他们得类型是不一样得，即使不用type()，也能看出来，一个没有括号括起来得，表示数值，一个用括号括起来得表示元组，而且同样有一个逗号，方便我们去区分这个括号表示的是什么 删除元组的特性相信大家都很熟悉了，就是元组的值是不可变的，创建好就是这样，没法改变，意味着我们不可以删除某个值，但可以把元组给删除12345tup7 = (1,2,3)print(tup7)print(&apos;-----------------&apos;)del tup7print(tup7) 创建元组我就不多讲了，删除一个元组可以使用del关键字，del tup7表示将元组变量整个删除123456(1, 2, 3)-----------------Traceback (most recent call last): File &quot;.\a.py&quot;, line 25, in &lt;module&gt; print(tup7)NameError: name &apos;tup7&apos; is not defined 我们通过输出可以看到，在没有删除之前是可以输出变量的，但是当我们删除之后再输出，可以看到报错了，NameError: name ‘tup7’ is not defined变量tup7不存在，这就表明我们已经彻底删除了元组tup7，关键字del不仅适用元组，其他数据类型也同样可以使用，这里就不操作给大家看了，大家可以自己去尝试下 元组的索引和切片下标我们先来理解什么是下标，下标就是元素的标号，通常就是用整数表示，从左往右0开始，从右往左-1开始，这里文字不好理解看图来解释 创建一个元组tup，里面的值是1，2，3，4，5。我们可以把tup看成是一个整体，里面的值是这个整体的元素，按照顺序，从左边开始，第一个元素的下标就是0，第二个就是1…以此类推，如果我们从右边开始，最右边的就是-1，倒数第二个就是-2…以此类推，可以多看看这张图，自己琢磨下，下标的用法在python里使用的频率是特别多的，所以这个一定要掌握 索引我们知道输出元组的值只要直接使用变量名就可以，但是我只想输出指定的元素，或者指定的下标呢？这就会用到索引1234tup8 = (1,2,3,4,5)print(tup8)print(tup8[3])print(tup8[-3]) 我们要输出指定下标时，可以通过[]来指定下标，如果要从左开始数就用正数，从右就要从负数，可以结合上面的图看，这里很多初学者都会弄混淆，因为左边是从0开始，很容易以为从1开始数，所以这里大家需要多练习123(1, 2, 3, 4, 5)43 还有一个初学者经常出错的地方就是超出下标，当索引的时候超出下标时就会报错，这也时报错比较多的12tup8 = (1,2,3,4,5)print(tup8[5]) 1234Traceback (most recent call last): File &quot;.\a.py&quot;, line 28, in &lt;module&gt; print(tup8[5])IndexError: tuple index out of range 这就是超出下标的报错，元组的下标超出了范围 切片我们可以输出指定下标的元素了，那我要输出某个下标到某个下标的元素呢，这就是切片，就像把一个整体，去掉头，去掉尾，咔嚓脆…回归正题，切片和索引差不多，也是用[]来表示，只不过里面用:来表示范围1234tup9 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;)print(tup9)print(tup9[1:4])print(tup9[-3:-1]) 在[]里，:左边表示开始的下标，右边表示结束的下标，但是真正的就说下标其实时你所写的下标减一，也就是说[1:4]，真正的范围时从下标1到下标3，而[-3:-1]的范围时-3到-2，这点需要大家注意123(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;)(&apos;b&apos;, &apos;c&apos;, &apos;d&apos;)(&apos;c&apos;, &apos;d&apos;) 花式作死为什么我会要弄个花式作死呢，用为切片这个东西很有趣，可以完成各种各样的切片，非常的花式，所以我们就来玩花式作死12345tup10 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;)print(tup10)print(tup10[5:])print(tup10[:8])print(tup10[:]) 先来简单的，上面说了用[]和:做切片，这里我们看代码:的又一侧是没有写下标，或者两边都不写，运行结果没有报错，说明python是会自动为我们加上的，如果左边没写，默认就是从左边第一个元素开始，右边没写就默认是到右边结尾最后一个元素，当然两边都不写那就是错左边第一个元素开始到右边最后一个元素结尾，这个很好理解1234(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;)(&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;) 我们来升级下作死1234tup10 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;)print(tup10)print(tup10[5::2])print(tup10[::3]) 代码里又多了一个:，这是什么鬼，前面是切片，后面又是什么，其实后面的冒号是步数的意思，就是说，在前面切片的范围里，我再按照指定的数进行跳跃，比如print(tup10[5::2])，如果没有后面的冒号就是从下标5的元素开始到右边最后一个元素，范围是(‘f’, ‘g’, ‘h’, ‘i’, ‘j’, ‘k’, ‘l’)，现在我加了步数是2，就是每隔两个的元素，从f开始，然后跳到第2个h，然后又跳到第2个j，一次类推。同样的print(tup10[::3])，范围是全部，步数是3。123(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;)(&apos;f&apos;, &apos;h&apos;, &apos;j&apos;, &apos;l&apos;)(&apos;a&apos;, &apos;d&apos;, &apos;g&apos;, &apos;j&apos;) 接下来终极作死123tup11=(1,2,3,(4,5,(6,7)))print(tup11)print(tup11[1::2][-1][::2]) 这个应该会难道一大片人，虽然这种代码很少会出现，但是能理解就可以了，不做强求我们来分析下print(tup11[1::2][-1][::2])的结果为什么是(4, (6, 7))12(1, 2, 3, (4, 5, (6, 7)))(4, (6, 7)) 首先我们要知道嵌套的元组是如何访问的，当访问嵌套元组时可以在后面再加个[]，表示访问下一嵌套，如果还有，就再来一个[]，就这样一直到你要访问的为止。我们来一步一步分析 tup11[1::2]，相信大家都能看出这个的结果是(2, (4, 5, (6, 7)))，这个我就不说了 tup11[1::2][-1]，我们上一步得到结果是(2, (4, 5, (6, 7)))，现在我们要嵌套[-1]，索引右边开始第一个元素，结果就是(4, 5, (6, 7)) tup11[1::2][-1][::2]，既然的到结果是(4, 5, (6, 7))，那下一个嵌套[::2]，就是从左边第一个元素到右边最后一个元素，加上步数是2，第一个就是4，跳到第2个，(6, 7)，所以结果就是(4, (6, 7)) 如果这个没搞懂也没关系，只要上面两个作死能理解就可以了，还有就是嵌套的元组如何访问的，懂这些就可以了 元组的运算元组也是可以做运算的，只不过不是数值之间的运算，只是合并和复制而已123456tup12 = (1,2)tup13 = (4,5)tup14 = tup12+tup13tup15 = tup12*2print(tup14)print(tup15) tup14 = tup12+tup13其实就是将元组tup12和元组tup13合并成一个新的元组而已tup15 = tup12*2就是将元组tup12复制两份然后合成一个新的元组12(1, 2, 4, 5)(1, 2, 1, 2) 不仅仅是+和*，还有in和is也同样可以使用1234tup12 = (1,2)tup13 = (4,5)print(4 in tup13)print((1,2) is tup12) 12TrueTrue 元组的方法终于到最后一个了，元组的方法，因为元组是不可变的，所以方法很少，也是些简单的方法，比如count()、index() count()用于统计某个元素在元组中出现的次数12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.count(1)) tup15.count(1)查询tup15里数值1出现的次数13 index()用于从元组中找出某个对象第一个匹配项的索引位置，如果不存在则报错12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.index(8)) tup15.index(8)查找数值8在元组tup15里第一个出现的索引位置12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.index(8)) 还可以指定开始到结束的下标，第二个是开始的下标位置，第三个是结束的下标位置，如果结束下标没写就默认是最后一个12tup15 = (1,2,3,4,8,1,2,3,1,3)print(tup15.index(1,1,7)) tup15.index(1,1,7)查询数值1在元组tup15下标1到下标6的索引位置15]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_04:python运算符]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-04-python%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[上一篇我们学习了3个基本类型，但是只是知道了这几个类型，还不知道到底能有什么，那么这篇我们就来学习运算符，把上一篇的知识融合进来。 运算符从字面上来理解就是运算的符号，就和在学校学的数学运算符一样，就是做运算用的，但是在编程语言里有一些是比较特别的，和平时的运算符有区别，那么废话不多说，来看看下面的结构图 从图片上可以看出，运算符分为7类，算术、比较、赋值、逻辑、位、成员和身份，这些我们都会在这篇文章里学到，大家不要被这看上去很多的样子所害怕，其实它们真的很简单，只要上过小学数学就完全可以学会 变量在正式讲运算符之前我们来引入一个新东西，它叫变量，变量是什么，可以简单的理解就是用来存储数据的，这么说有点抽象，那我们通过一个例子来理解。 例子现在假如家里有一推衣服和鞋子，两个收纳盒，把衣服和鞋子都按类放在收纳盒里，以便下次需要的时候方便找到。我们来分析这整个过程 首先我们要有两个收纳盒，为了方便辨别收纳盒里放的是什么我们给收纳盒贴个标签，分别命名为clothes和shoes。这个过程我们就可以认为是变量命名，因为变量可以有很多个，为了方便知道变量都是存的什么，我们可以给变量取一个名字，叫命名变量 既然收纳盒有了，也知道收纳盒里都放什么了，那我们旧把衣服放进标有衣服标签的收纳盒，鞋子放进标有鞋子标签的收纳盒。这个过程我们就可以认为是赋值给变量，既然有变量了，那总得存点什么数据，我们就可以赋值，叫变量赋值 这就是变量的作用和存储的过程，这里只是举了个简单的例子说明了变量，其实变量是很深奥的，如果真的把全部讲清，可能很多人都看不懂，目前我们知道会用变量就可以了，至于变量的存储内部到底怎么实现的，存的到底是不是就是我们赋值的，这个到以后在详细的探讨 命名变量变量的命名是有规定的。 变量名只能包含字母、数字、下划线，变量名可以以字母和下划线开头，但不能以数字开头。 比如：students，Teacher，_school，people5都是可以的 比如：5apple就是错的 变量名中不能有空格，可以用下划线代替。 比如：students_name是可以的 比如：teacher name，这样就是错的 不要用Python中的关键字作为变量名。 所谓的关键字就是python已经定义好的名字，这些名字是有意义的，我们就不能作为变量名了 比如：print就不能作为变量名，print有它的意义，他可以作为打印输出，如果你非要使用这个变量名可以用开头大写，python是区分大小写的，print和Print就不是同一个东西了 变量赋值变量赋值就是讲数据赋值给变量，可以使用=来赋值，比如：stu_name=”小明”,这就是赋值，很简单吧，并没什么难得，关于赋值我们会在下面更详细的讲解 算术运算符算术运算符就是做简单计算用的，加减乘除这些都在小学学过了，我就不废话了除了这几个还有2个，分别是求余、整除和指数 求余就是将除法等到的余数部分提取出来，这个在一些场景下非常有用整除正好相反，只提取整数部分指数就是求次方，和小学的指数一样我们用代码来体验一下12345678910111213141516a=10b=3c=a+bprint(&quot;a+b=&quot;,c)c=a-bprint(&quot;a-b=&quot;,c)c=a*bprint(&quot;a*b=&quot;,c)c=a/bprint(&quot;a/b=&quot;,c)c=a%bprint(&quot;a%b=&quot;,c)c=a//bprint(&quot;a//b=&quot;,c)c=a**bprint(&quot;a**b=&quot;,c) 输出的结果1234567a+b= 13a-b= 7a*b= 30a/b= 3.3333333333333335a%b= 1a//b= 3a**b= 1000 现在开始我们就会用上面讲到的变量了，这里声明了3个变量，分别是a，b和c，然后将10赋值给a，3赋值给b，而c的值就是a和b运算后的结果。在这要说一下，python是不需要声明变量的类型的，因为python会自动去识别。再看print也变得和以前稍微不同了，前面字符串很好理解，就不再说了，后面多了一个逗号，又一个变量名。都好的作用就是分隔，表示前面和后面的不是一起的，需要分开，前一篇说过，只有字符串打印输出才要加引号，所以打印输出变量的时候，可以直接用变量名就可以输出变量的值 好了，回到我们的代码，前面加减乘除就不解释了，大家都懂的，说说后面3个 %：这是求余符号，10除3，商3余1，那么余数就是1，结果就是1 //：整除，和除法要区分开，除法是一个/，10除3，是3.3333333333333335，整数部分是3，那结果就是3 **：指数，也同样要和乘法区分开来，指数运算就没什么好说的了 最后我们来看看除法，按道理10除3结果是3.333333333333333…,无限循环3才对，怎么最后是5了呢？这是因为浮点数它在机器里是以十进制表示的方式是无限趋近于结果，会造成准确性下降，但这也只是最后几位的才会出现。这里要真的解释清楚不是一时半会的事，如果你有计算机基础或感兴趣的可以看看python官网给的解释 比较运算符顾名思义，就是比较时候用的运算符，基本上就是等于（==）、不等于（!=）、大于（&gt;），大于等（&gt;=）、小于（&lt;）、小于等于（&lt;=） 不等于，大于，大于等于，小于，小于等于大家一眼就能看出来，这里主要说说等于 等于是用两个等号来表示的，千万不要的赋值符号搞混了，这是很多初学者都会犯下的一个错误。比较运算得到的结果一般都是布尔类型的，要么是真，要么是假，不会出现其他的。123456789a=10b=3print(&quot;a&gt;b is&quot;,a&gt;b)print(&quot;b&gt;=a is&quot;,b&gt;=a)print(&quot;b&lt;a is&quot;,b&lt;a)print(&quot;a&lt;=b is&quot;,a&lt;=b)print(&quot;a==b is&quot;,a==b)print(&quot;a!=b is&quot;,a!=b) 这次我们并没有使用第三个变量来接收a和b运算后的结果，而是直接在print里写上运算，这是可以的，最后输出的结果为下图123456a&gt;b is Trueb&gt;=a is Falseb&lt;a is Truea&lt;=b is Falsea==b is Falsea!=b is True 比较运算符就完事啦，很简单有木有 赋值运算符赋值运算符在讲变量的时候就已经讲过一个赋值符号了，其是赋值运算符就这么一个，其它的都是和算数运算符组合起来，我们直接看代码12345678910111213141516171819num1=5num2=8print(&quot;num1=&quot;,num1)print(&quot;num2=&quot;,num2)num1+=num2print(&quot;num1+=num2的结果是&quot;,num1)num1-=num2print(&quot;num1-=num2的结果是&quot;,num1)num1*=num2print(&quot;num1*=num2的结果是&quot;,num1)num1/=num2print(&quot;num1/=num2的结果是&quot;,num1)num2%=num1print(&quot;num2%=num1的结果是&quot;,num2)num2//=num1print(&quot;num2//=num1的结果是&quot;,num2)num1**=num2print(&quot;num1**=num2的结果是&quot;,num1) 上面都用上了赋值运算符，我只讲一个+=，其它的都是同理，num1+=num2相当于num1=num1+num2，当然刚开始可能还不是很熟悉，也可以使用算术运算符，等熟练了再用赋值运算符也是完全可以，这个完全取决于个人123456789num1= 5num2= 8num1+=num2的结果是 13num1-=num2的结果是 5num1*=num2的结果是 40num1/=num2的结果是 5.0num2%=num1的结果是 3.0num2//=num1的结果是 0.0num1**=num2的结果是 1.0 来看看输出的结果，看上去感觉怪怪的，好像有几个不对啊，怎么计算不对呢，难道机器出问题了？答案当时不是啦，这些都是对的，我们一个一个来讲解 num1=5，num2=8这个没啥好说的，大家都会了 num1+=num2的结果是 13，前面也讲了，就是把左边的加上右边的再赋值给左边的，把数字代进去就是num1=5+8,结果13,没毛病 num1-=num2的结果是 5，按照前面说的做，num1=5-8，结果应该是-3啊，怎么是5了，回想下上一步，num1的结果是多少，是13，在运算num1-=num2的时候有对num1赋值过其他的值么？没有吧，那么num1现在就是13，现在把13代进去。num1=13-8，结果是5，对了吧 num1*=num2的结果是 40，这个刚好误打误撞，前面得到的num1是5，又和一开始赋的值一样了，所以结果就是40 num1/=num2的结果是 5.0，这个现在大家能看出来了吧，num1的值已经是40了，不再是5了 num2%=num1的结果是 3.0，同样的道理，num1是5，而num2我面前面都没赋值，只是一开始赋过值，但是没有变，所以num2依旧还是8，8%5，结果现在大家都会算了，是3 num2//=num1的结果是 0.0，这里num2在上一步已经赋值成3了，而num1上一步没赋值，还是num1/=num2的值，5。代进去算下，整数部分是0 num1**=num2的结果是 1.0，num2的值已经是0了，任何说的0次方都等于1 讲解完后，我们改下代码，把num1和num2在每次运算后的值都打印出来看看，对不对12345678910111213141516171819num1=5num2=8print(&quot;num1=&quot;,num1)print(&quot;num2=&quot;,num2)num1+=num2print(&quot;num1+=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1-=num2print(&quot;num1-=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1*=num2print(&quot;num1*=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1/=num2print(&quot;num1/=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num2%=num1print(&quot;num2%=num1的结果是&quot;,num2,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num2//=num1print(&quot;num2//=num1的结果是&quot;,num2,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2)num1**=num2print(&quot;num1**=num2的结果是&quot;,num1,&quot;,num1=&quot;,num1,&quot;,num2=&quot;,num2) 在这里print后面多了更多的逗号了，前面讲过它的作用，这里就不再重复了，现在我们就这样，到后面我们学习高级的打印输出，会比这种省事很多123456789num1= 5num2= 8num1+=num2的结果是 13 ,num1= 13 ,num2= 8num1-=num2的结果是 5 ,num1= 5 ,num2= 8num1*=num2的结果是 40 ,num1= 40 ,num2= 8num1/=num2的结果是 5.0 ,num1= 5.0 ,num2= 8num2%=num1的结果是 3.0 ,num1= 5.0 ,num2= 3.0num2//=num1的结果是 0.0 ,num1= 5.0 ,num2= 0.0num1**=num2的结果是 1.0 ,num1= 1.0 ,num2= 0.0 位运算符位运算符就是把数字看作二进制来进行计算的，把二进制的每一位做运算 进制我们在现实生活中经常使用十进制，从0到9，超过9后就进一位，变成10，这个大家都知道，在计算机里不仅仅只有十进制，还有二进制，八进制，十六进制，其中二进制用的是最多的，紧接着十六进制，八进制到用的比较少 二进制只有0和1，逢二进一，比如：1010，这就是个二进制，只是这样看和十进制一样，很难区分，所以我们可以加上前缀0b或者0B，完整的二进制表示方法0b1010或者0B1010 十六进制也是一样的，逢十六进一，从数字0到9，之后就是从字母a到f，比如：1f2b，十六进制用0x或者0X表示，0x1f2b或0X1f2b 八进制也一样，从数字0到8，逢八进一，比如：137，八进制用0o或者0O表示，0o1f2b或0O1f2b 注意：前缀的第一个都是数字0，后面的是字母，数字0和字母o长得很像，很容易搞错，这一点一定要仔细 还有一个就是进制之间的转换问题，这个大家可以看看这篇文章里面讲的很详细。 我们在看看在python里是如何讲各种进制输出的123456a=25print(&quot;a的十进制是&quot;,a)print(&quot;a的二进制是&quot;,bin(a))print(&quot;a的十六进制是&quot;,hex(a))print(&quot;a的八进制是&quot;,oct(a)) 十进制直接使用就可以了，可以用bin()来将十进制转换二进制，然后输出，同样的，十六进制用hex()，八进制用oct()1234a的十进制是 25a的二进制是 0b11001a的十六进制是 0x19a的八进制是 0o31 位运算回到我们的正题，位运算符，既然我们知道二进制怎么表示后，我们就可以正式的来认识位运算符了，位运算符是二进制每一位的运算，可以分为与(&amp;)、或(|)、异或(^)、非(~)、左移(&lt;&lt;)、右移(&gt;&gt;),要想记住他们的运算规则，只要记住下面表里的规则就可以了12345678910a=3b=6print(&quot;a=&quot;,bin(a),&quot;,b=&quot;,bin(b))print(&quot;a&amp;b=&quot;,a&amp;b)print(&quot;a|b=&quot;,a|b)print(&quot;a^b=&quot;,a^b)print(&quot;~a=&quot;,~a)print(&quot;b&gt;&gt;2=&quot;,b&gt;&gt;2)print(&quot;b&lt;&lt;2&quot;,b&lt;&lt;2) 1234567a= 0b11 ,b= 0b110a&amp;b= 2a|b= 7a^b= 5~a= -4b&gt;&gt;2= 1b&lt;&lt;2 24 根据上面的口诀，按照每一位进行运算 与（&amp;）：a是11，b是110，a差一位，就在高位补一个0，不影响结果，a变成011，好了，位数相同了，从低位开始，1和0，只有一个1得0，1和1，全1得1，0和1，只有一个1得0，最后结果就是010，去掉最高为没意义得0就成了10,十进制就是2 或（|），也同样得，只要有一个1就得1，结果是111，十进制就是7 异或（^）:不同得1，根据口诀得到得结果是101，十进制就是5 非（~）:这个就有点特殊了，先根据口诀，0和1颠倒，得到100，但前面为什么会出现符号呢，因为数值的存储和读取问题，可以看这篇文章。 右移（&gt;&gt;）：右移两位，去掉最低的两位就是变成了1，十进制也是1 左移（&lt;&lt;）:同理，左移2位丢弃高位，低位补0，但是高两位并不是就是11，应该把二进制补全成8位的二进制，00000110，最高为是0，去掉，最低补上0，变成00011000，十进制就是24 逻辑运算符逻辑运算符就是判断逻辑的，和位要区分开来，逻辑运算符有and、or、not，主要是做bool运算，同样也有口诀帮助大家记12345678print(&quot;True and False = &quot;,True and False)print(&quot;True and True = &quot;,True and True)print(&quot;True or False = &quot;,True or False)print(&quot;True or True = &quot;,False or False)print(&quot;not False = &quot;,not False)print(&quot;not True = &quot;,not True) 123456True and False = FalseTrue and True = TrueTrue or False = TrueFalse or False = Falsenot False = Truenot True = False 感觉跟位运算符差不多，只不过是换成了布尔值，这里稍微扩展下，凡是非0的数都是Ture，这也就是，数字也可做逻辑运算，布尔值也可以做算术运算12print(int(True))print(int(False)) int()表示将括号里的数据类型强制转换成整数类型1210 False的值为0，True的默认值是1，那我们来试试将数字转换成布尔类型12print(bool(0))print(bool(5)) bool()是将数据强制转换成布尔类型12FalseTrue 可以看到只要是0就是False，非0就是True 了解了这些我们来用bool做算术运算12print(True+True)print(False-True) 122-1 再来看看用数字做逻辑运算12345678print(&quot;1 and 0 = &quot;,1 and 0)print(&quot;3 and 7 = &quot;,3 and 7)print(&quot;8 or 0 = &quot;,8 or 0)print(&quot;0 or 0 = &quot;,0 or 0)print(&quot;not False = &quot;,not 0)print(&quot;not True = &quot;,not 16) 1234561 and 0 = 03 and 7 = 78 or 0 = 80 or 0 = 0not False = Truenot True = False 最后的not还是显示的布尔值，结果和用布尔值运算是一样的 成员运算符成员运算符就是在不在的关系，可以想象成有一个队伍，某人在不在这个队伍里，是不是这个队伍的成员。比如字符串abcdefg，问d在字符串里吗？，答案肯定是在的，用bool来表示结果就是True，如果不在，就用False。1234567s=&quot;我是一名新博客主&quot;print(&quot;博客两字在变量s里吗？答案是：&quot;,&quot;博客&quot;in s)print(&quot;Damo两字在变量s里吗？答案是：&quot;,&quot;Damo&quot;in s)print(&quot;博客两字在不变量s里吗？答案是：&quot;,&quot;博客&quot;not in s)print(&quot;Damo两字不在变量s里吗？答案是：&quot;,&quot;Damo&quot;not in s) 1234博客两字在变量s里吗？答案是： TrueDamo两字在变量s里吗？答案是： False博客两字在不变量s里吗？答案是： FalseDamo两字不在变量s里吗？答案是： True 可以看到，成员运算符在做判断的时候很有用 身份运算符身份运算符就是判断是不是的关系，就像身份证一样，唯一的标识，差一点都不对，也是用bool表示结果1234567s=&quot;1a2b&quot;print(&quot;1a2b和s一样吗？答案是：&quot;,&quot;1a2b&quot;is s)print(&quot;1a2c和s一样吗？答案是：&quot;,&quot;1a2c&quot;is s)print(&quot;1a3b和s不一样吗？答案是：&quot;,&quot;1a3b&quot;is not s)print(&quot;1a2b和s不一样吗？答案是：&quot;,&quot;1a2b&quot;is not s) 12341a2b和s一样吗？答案是： True1a2c和s一样吗？答案是： False1a3b和s不一样吗？答案是： True1a2b和s不一样吗？答案是： False is和==好了，所有的运算符都讲完了，在这最后讲讲is和==的区别，两个都是用来判断是否相同，但是两者的区别可大了 ==：等于号是用来做比较，也就是比较两个值是否相等，常常用来比较数值 is：is不仅仅要是值相同，而且内存中的地址也要相同 我们来重点说说is，is它判断两个东西。第一个是值必须相同123456a = 1b = 1c = 2print(a is b,b is c)print(id(a),id(b),id(c)) id()是输出括号里的内存地址12True False140715950072656 140715950072656 140715950072688 可以看到，值相同，地址相同，最后的结果才是True。这里的结果可能会和你们的不一样，这个每个人的电脑都会有不同的结果，主要是输出的3个值都是一样的就对了，如果这还不能看出却别，我们来看看下面的代码123456789&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 500&gt;&gt;&gt; a = 500&gt;&gt;&gt; print(a == b)True&gt;&gt;&gt; print(a is b)False&gt;&gt;&gt; print(id(a),id(b))2149012190704 2149011769232 这是在交互模式下运行的，只为了说明is，并不推荐用交互模式写程序，这是交互模式的一个很坑的问题，正好可以说明is。开启交互模式时，会为用户创建号小整数的内存地址，所以超过这个范围的时候，两个变量就会指向不同的内存地址。 现在应该能看出is的和==的区别了，虽然值都相同，但时内存地址不用，对于is来说就是不同，所以时False 这一篇全部讲完了，内容稍微有点多，都是要记的，还是希望大家能多加练习，那么我们下一篇再聊吧]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_03:python基本数据类型]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-03-python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这一篇我们来学习python的基本数据类型，这也是学任何编程语言都必须掌握的一个很重要的东西。 python文件创建在正式讲数据类型前我们现在说下前面没有提到的一个东西，就是python文件，我们的所有代码都会写在一个文件里，这样可以保存下来，在下次用的时候可以直接使用，或者直接修改。所有的python文件都是以.py结尾的，如果是手动创建文件的话，要记得把结尾改成.py，如果是用IDE的话，可以直接创建python文件，不会的话可以百度下自己使用的IDE如何创建python文件。 python输入和基本格式我们在上一篇文章中在交互模式中输入了print(“Hello python!”)，这就是最简单的输出，print是打印的意思，告诉输出器，将括号里的双引号里的内容打印到显示器上，所以按下回车后我们能看到立马打印出了Hello python!。我们可以用print打印任何内容，比如数字，单词，汉字，符号等等，也可以将这些混合输出。1234&gt;&gt;&gt; print(&quot;你好&quot;)你好&gt;&gt;&gt; print(&quot;今天是1月30日，I Love Python！&quot;)今天是1月30日，I Love Python！ 可能有些小伙伴想在打印出双引号，可是在当按下回车的时候报错了。12345&gt;&gt;&gt; print(&quot; &quot;我就是我，不一样的烟火&quot; &quot;) File &quot;&lt;stdin&gt;&quot;, line 1 print(&quot; &quot;我就是我，不一样的烟火&quot; &quot;) ^SyntaxError: invalid character in identifier 这是你们以后可能会经常遇到的错误，SyntaxError: invalid character in identifie的意思是语法错误：标识符中的字符无效，为什么会这样的，明明和以前的输入没什么区别，却报错了，原因很简单，就是因为print识别你所输入的内用是靠一对双引号来识别的，它识别一对双引号之间的内容，“ “我就是我，不一样的烟火” “，可以看到这句里有两对双引号，前面一对，后面一对，中间的并没有双引号，print不知道你输入的是什么东西，所以它就报错了，告诉你语法错误，可是我就想输出双引号怎么办，很简单，只要在要输出的双引号前加上\即可12&gt;&gt;&gt; print(&quot; \&quot;我就是我，不一样的烟火\&quot; &quot;) &quot;我就是我，不一样的烟火&quot; 这样我们就可以输出双引号了，先不用知道\是干嘛用的，知道可以输出双引号即可 重点！ python是区分大小写的，如果你输入的大小写不正确的话，得到的结果也会不一样 在python里所有的符号都必须是英文下的符号，如果用中文符号的话就会报错，这也是很多初学者很容易犯的一个错误 python的每一句末尾不需要加上;，因为在python里，一行就是一句代码。如果你想加上也是可以的，不会对程序有任何影响，但是如果一行里有多句代码的时候，就会报错，所以请一行就是一句代码 基本数据类型python的数据类型有许多，但是基本类型有8种，可以按照可不可变分为两大类。 不可变类型：就是这些类型的值是不可以改变，不可变类型又可以分为5种，分别是数字（number）、字符串（string）、布尔（bool）、元组(tuple)、None 可变类型：就是这些类型的值是可以改变的，可变类型又可以分为列表（list）、字典（dictionary）、集合（set） 这些基本的的数据类型在将来我们会经常用到，整个结构可以看下面的图片 在这篇中我们不会把所有的类型都讲解一遍，先讲数字、字符串和布尔，其他在后面再讲，刚开始我们用不到那么多，有数字、字符串和布尔就够用了。 数字（Number）数字很容易理解，就是我们平时用的数字，比如1，3.1415926，这些都是数字，但是再python里面数字又分为整型和浮点型下面我们就来对这两种类型做详细的探讨 整型（int）整形就是数字的整数部分，也就说小数点左边的部分，整型很简单。再python里整形用int来表示，在python3里int是不区分大小的，也就是这个数字可以很大，能大到多少，我也不记得，反正是够我们用，我们可以通过print打印输出一下123456&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print(10)10&gt;&gt;&gt; print(123456789012345678901234567890)123456789012345678901234567890 在这里可以看到输入的数字是多少，输出就是多少，细心的小伙伴可能发现了，在这里并没有加双引号，这是因为输入的是数字，而不是字符串，python是能直接识别出来的，所以不用加上双引号，这个双引号的问题会在这篇最后和大家详细探讨，到底什么时候要加双引号 浮点型（float）浮点型其实就是我们平常所说的小数，带小数点的数，作者第一次接触浮点数时还以为是会浮起来的数，还满怀好奇心，得知后才发现自己多幼稚，好了，回到正题上，浮点数只要直接输入就可以了1234&gt;&gt;&gt; print(1.23)1.23&gt;&gt;&gt; print(456.321)456.321 字符串（string）可以简单理解为就是字符、文字、符号，通常是用引号引起来的，python是个非常人性话的，字符串不管你是用单引号，双引号，三引号，他都会认为这就是字符串，不想其他语言，双引号是字符串，单引号是字符，python统统认为是字符串，即使你引号里只有一个字符，它也认为是个字符串。 单引号和双引号单引号，用单引号引起来的的字符串，其实和双引号没什么区别，但是为什么还要区分单引号和双引号，原因很简单，你可试想下如果我要用单引号输出i’m a good boy,该怎么输出，只要输入python(‘i\’m a good boy’)12&gt;&gt;&gt; print(&apos;I\&apos;a a good boy&apos;)I&apos;a a good boy 我们可以直接使用\将单引号输出，这样还是看不出单引号到底有什么用，那么我们输出这句呢？We all know that ‘A’ and ‘B’ are two capital letters.12&gt;&gt;&gt; print(&apos;We all know that \&apos;A\&apos; and \&apos;B\&apos; are two capital letters.&apos;)We all know that &apos;A&apos; and &apos;B&apos; are two capital letters. 可以看到多好几个单引号，每个前面都要用\，很麻烦，可读性太差了，所以这时候我们可以用双引号来表示字符串，这样在双引号里的单引号就不用加\了12&gt;&gt;&gt; print(&quot;We all know that &apos;A&apos; and &apos;B&apos; are two capital letters.&quot;)We all know that &apos;A&apos; and &apos;B&apos; are two capital letters. 同样的道理，如果带双引号的字符串里也有双引号的话，我们就可以用单引号在表示字符串。12&gt;&gt;&gt; print(&apos;The teacher said: &quot;Practice makes perfect&quot; is a very famous proverb.&apos;)The teacher said: &quot;Practice makes perfect&quot; is a very famous proverb. 现在知道为什么会有单引号和双引号了吧，就是为了方便我们在不同的字符下能很好的把引号输出来，增强代码的可读性 到这里，有小伙伴就想到了很绝的问题，那我字符串里又有单引号又有双引号怎么办？那么接下来的三引号完美解决这个问题 三引号前面我们知道了单引号和双引号的区别后，留下了一个大问题，就是字符串里又有单引号又有双引号。我们先来把这个问题解决了，用法和前面的一样，只是字符串换成了三个单引号组成三引号而已12print(&apos;&apos;&apos;父亲对小明说:&quot;咱们这地方出产的&apos;龙井&apos;可是上等好茶，明天你带上几斤去探望你们的老师。&quot;&apos;&apos;&apos;)父亲对小明说:&quot;咱们这地方出产的&apos;龙井&apos;可是上等好茶，明天你带上几斤去探望你们的老师。&quot; 好了这个问题轻松解决，我们再回到三引号的问题上，其实三引号不单单只是为了方便输出单引号和双引号，它最大的用处在于，它可以在你一行内容太多的时候换行继续写，前面也介绍了python一行就是一句代码，但是有时候字符串特别长，为了可读性我们可以换行写。12345678&gt;&gt;&gt; print(&apos;&apos;&apos;aaaaaaaaaaaaaaaaaaaaaaaa... bbbbbbbbbbbbbb... cccccccccccccccc... dddddddddddd&apos;&apos;&apos;)aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbccccccccccccccccdddddddddddd 这里我说明下，若果再交互模式换行后会出现三个点，表示等待用户继续输入的意思，直到完成一句完整的代码，回车才会执行。 布尔型（bool）布尔类型的值只有2个，分别是True和False，从单词上就能看出，一个表示真，一个表示假，没错，布尔类型就是表示真和假这么简单，我们打印输出一下1234&gt;&gt;&gt; print(True)True&gt;&gt;&gt; print(False)False type()现在我们回到一开始遗留下来的问题，print里到底什么时候要加双引号，其实这个就是关系到数据类型的问题，现在我们学了三种数据类型，数字、字符串和布尔，当我们输出字符串的时候都带有引号，而数字和布尔时并没有加，所以可以看出，凡是带有引号的都是字符串，理解这一点后我们来看看下面的两句输出1234&gt;&gt;&gt; print(&quot;1&quot;)1&gt;&gt;&gt; print(1)1 这两句都是输出1，结果乍一看没什么区别，其实它们有着很大的区别，先来回想一下刚才所说的，凡是带有引号的都是字符串，那么很容易看出第一句输出的是字符1，而第二句输出的是数字1.光说没什么用，那我们就来验证一下对不对，在这里我们再学一个新函数(函数是什么后面会讲解到)，type(),这个函数可以输出括号里输入的类型，那么我们来验证下刚才问题1234&gt;&gt;&gt; print(type(&quot;1&quot;))&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; print(type(1))&lt;class &apos;int&apos;&gt; type(“1”)把”1”输入到type函数里，然后type输出了类型，但是没法打印出来，所以我们外面再套一层print，这样我们就可以在显示器上看到输出的结果 我们可以看到两句输出的类型都不一样，&lt;class ‘str’>，class表示类（后面将会学到类），紧接这是str，这是字符串的string的缩写，可以看出这句的类型是字符串，下面那一句也是一样，但是输出的是int，这是整数类型，现在应该知道什么时候用引号了，既然我们用了type()了，那我们来验证下浮点型的数字和布尔类型123456&gt;&gt;&gt; print(type(1.23456))&lt;class &apos;float&apos;&gt;&gt;&gt;&gt; print(type(True))&lt;class &apos;bool&apos;&gt;&gt;&gt;&gt; print(type(False))&lt;class &apos;bool&apos;&gt; 嗯，验证后没问题，这就是浮点型(float)和布尔类型（bool） 好了，这篇就到这里了，内容不是特别多，都是写记忆性的东西，代码还是希望大家多敲。下一篇我们将学习运算符。那么我们下一篇见]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始_02:python安装]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-02-python%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这一篇将教大家如何在linux和window平台下载及安装python，还会推荐几个本人用过的IDE，希望能帮助大家快速在自己点电脑搭建好环境 window用户window安装python需要到官网下载安装包进行安装。 下载python首先我们打开浏览器，在网址栏里输入https://www.python.org/，或者在百度里搜索python找到官网。 进入官网后点击导航栏的Downloads跳转到下载页面 跳转到下载页面后会自动检测你当前浏览官网的操作系统是什么，如果你是window操作系统，会显示Download the latest version for Windows，核对操作系统无误后就点击文字下方的Download Python 3.7.2进行下载。如果显示的不对就在在红框中选择自己电脑的操作系统 安装下载好安装包后，双击安装包 进入安装界面我们选择自定义安装，下面两个勾一定要打上，特别是第二个添加环境变量，打勾后在后面就可以省略配置环境的步骤，如果忘了打勾耶没关系，后面教大家如何手动添加环境变量 这里没什么好说的，能打勾都打上，然后我们点击Next进行下一步 在这里请把1、2、3、4、5项打上勾，然后可以将安装路径改为自己想安装的地方，不建议大家安装到系统盘里，然后点Install开始安装如果出现了下图红框里的setup was successful表示安装完成了，点击Close 配置环境变量如果你在安装的时候将环境变量的选项打勾了的话，可以跳过这一步，如果你忘了打勾，没关系，我们手动配置即可 首先我右击我的电脑选择属性 然后我们选择高级系统设置 然后再选择环境变量 找到系统变量，选中Path这一项，然后再选择编辑 再编辑环境变量界面里将python目录下的Scripts目录添加进去即可的 测试同时按下win键和R键，然后输入cmd，回车打开doc（命令提示符） 然后输入下面的指令(注意，V是大写的)1python -V 如果没有显示任何错误且显示了python和对应的版本则说明安装成功了! Linux用户如果你是Linux用户的话，那就很轻松了，一般Linux是自带python，而且版本还是比较新的，打开Linux终端输入python3 -V（Linux下的python是区分2和3的，如果是2的话，只要输入python即可，3的话要输入python3）123zs@zs:~$ python3 -VPython 3.5.2zs@zs:~$ 如果已经安装效果会和window一样，显示python和对应的版本，如果没有的话或者没有python3的版本我们就自己安装一个，在这里我只以Ubuntu为例，其他的也是类似的，可以再网上找到对应教程，我们在终端输入sudo apt-get install python3,然后会出现提示说是否继续，输入y回车继续，然后静静的等待安装完成即可，完成后我们输入python3 -V检测是否成功。Linux下的python3就已经安装完成了。 Mac用户如果你是Mac用户的话，一般情况也是自带，这里因为我没有Mac系统的电脑，所以这里将无法演示，但是安装的步骤基本上和window一样。如果实在不会，可以看看这篇文章(mac安装python)，里面讲解了Mac下如何安装python3 python的交互模式通过上面的方法我们完成了python3的安装，接下来我们来说python3的交互模式。 可以简单的理解为人机交互，就是我输入一些东西，立马就会得到输出的结果。这样的好处在于，需要做简单的代码测试的时候，可以很快的得到结果，但是，这样是有缺点的，就是代码量不能太多，一旦代码量多的话就会出现自己都不记得自己前面写的代码是什么，可读性很差。 接下来我们来启动python3的交互模式，无论是什么操作系统下的python，启动方法都是一样的，我们打开终端输入python(在这里说明一下：如果你的电脑装有多个版本的python，你可以输入python后面加上你要启动的版本号即可开启你想要的版本，Linux下是自带python的，2和3都有，可以输入python3开启交互模式**)1234C:\Windows\system32&gt;pythonPython 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 这样我们就开启了交互模式，我们可以看到，已开启可以看到python的版本和一些其他的信息，最下面有一个&gt;&gt;&gt;符号，这是说明等待用户输入的意思，我们现在来输入一句简单代码，现在还不用知道是什么意思，这些代码再后面会讲到。好了，我们输入print(“Hello python!”)123456C:\Windows\system32&gt;pythonPython 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; print(&quot;Hello python!&quot;)Hello python!&gt;&gt;&gt; 当我们输入完print(“Hello python!”)后，按下回车，电脑立马就给我们输出了Hello python!，然后下面又出现了&gt;&gt;&gt;的符号，这就是python的交互模式。输入exit()即可退出交互模式 但是，我们是要写程序的，代码量不可能就这么几句，所以我们这下来选一个自己顺手的IDE（集成开发环境），这样可以提高我们大代码编写速度和可读性 IDE个人推荐现在网上有很多的ID，都各有千秋，所以这里我就不去介绍这些IDE了，我只对我用过的IDE做简单介绍，推荐几款我用的比较顺手的IDE给大家 pycharmpycharm是为python专门打造的IDE，功能非常强大，但是这款IDE很大，启动速度会比较慢，基本上在大公司里都会用这款IDE去开发python的程序，如果感兴趣的话可以去pycharm官网看看,安装教程的话现在网上一大把，随便百度下就有了，还有，这款IDE需要破解才能发挥出它的强大之处，至于怎么破解，甩锅给百度就好了，我就不说了。。。 sublime textsublime text是一款集合了目前为止比较流行的编程语言的IDE，不仅可以用来编写python，还可用来编写java，c，c++，c#，html等等，体积不大，启动速度是我用过最快的一款，但是它没有pycharm那样强大，很多强大的功能需要自己去安装插件，可是插件的安装对新手来说很不友好，安装方法很麻烦，还不稳定，不知道是不是我的方法有问题，反正，这款IDE非常适合有一定经验的人使用。sublime text官网,安装方法和后续的找度娘 atomAtom是github开发的，专门为程序员开发的一款IDE，同样小巧，启动速度的话会比sublime text慢一些，同样需要安装插件来增强atom，它的插件安装可就简单多了，在IDE里直接搜索你想要的插件，下载就可以安装好了，这也是我用的最舒服的一款，同样可以编写大部分的编程语言，而且这款IDE火起来的原因是，你在敲代码的时候，会有抖动的动态效果，非常震撼，但是没什么卵用，只能无聊时装X，atom官网，安装方法的话百度也有，这里就不做过多的介绍了。 vim有用过Linux的用户看到vim肯定会疑惑，我为什么会推荐vim，对，vim不属于IDE，而且window很少人回去用，但是我还是要推荐它，Linux可不像window一样，有很多都用不了，所以我推荐了一款Linux下的编辑器，运行速度没得说，一个字！快。。。功能的话，这只是的编辑器，就我们常用的文本编辑器一样，不要急，它不是一无用处，它也可能打造成IDE，功能的话还行，当年我在Linux编写程序的时候就是用vim，安装各种插件，把编辑器变成了一个简单的IDE，用久了还觉得很舒服。 总结最后是总结下推荐的这4款IDE，如果你是window用户的话，电脑也比较牛的话推荐用pycharm，简单又强大，如果电脑配置没那么好的，可以试试sublime text或者atom，这两款都差不多，哪个顺手用哪个。如果是Linux用户的，前面几个也是可以的，但是安装起来就会比较麻烦，如果不想麻烦的话，可以尝试下vim。当然这里推荐的都觉得不合适的话，可以自己去百度查找一款合适自己的IDE，这是完全没问题的，毕竟IDE只是一个工具，提高我们开发的速度和可读性，完全没比较纠结功能强不强大，只要自己用的顺手就好 好了，这篇就到这里结束了，现在我们安装好了python，也安装好了IDE，接下来我们就可以正式的开始进入python的大门了，从下一篇开始就开始学习python的一些基础知识了，这里我想和大家说 代码只看没什么用，它不认识你，只有多敲代码，这样才能提高自己]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开开始_01:python简介]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%BC%80%E5%A7%8B-01-python%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Python是一种计算机程序设计语言。是一种动态的、面向对象的脚本语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 python的起源Python是由一位Guido von Rossum叫荷兰人创造，俗称龟叔。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。 在那个时候，他接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 然而，这种思考方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间 (即使他已经准确的知道了如何实现)。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器(interpreter)已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词(word)的总数：(以下代码没必要懂，了解即可)1234567HOW TO RETURN words document: PUT &#123;&#125; IN collection FOR line IN document: FOR word IN split line: IF word not.in collection: INSERT word IN collection RETURN collection HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号(:)和缩进来表示程序块(C语言使用{}来表示程序块)。行尾没有分号。for和if结构中也没有括号()。如果将HOW TO改为def，将PUT行改为collection = []，将INSERT行改为collection.append(word)，这就几乎是一个标准的Python函数。上面的函数读起来就像一段自然的文字。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。 python的诞生1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森干的飞行马戏团》（Monty Python’s Flying Circus）。 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。 最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。 python的应用好了，上面讲了那么多，现在我们来看看我们学的python到底能做什么？ 目前Python主要应用领域 云计算: 云计算最火的语言， 典型应用OpenStack WEB开发: 众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣。。。， 典型WEB框架有Django 科学运算、人工智能: 典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas 系统运维: 运维人员必备语言 金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java,尤其擅长策略回测 图形GUI: PyQT, WxPython,TkInter Python在一些公司的应用 谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发CIA: 美国中情局网站就是用Python开发的NASA: 美国航天局(NASA)大量使用Python进行数据分析和运算 YouTube:世界上最大的视频网站YouTube就是用Python开发的 Dropbox:美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载 Instagram:美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发 Facebook:大量的基础库均通过Python实现的: 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的 豆瓣: 公司几乎所有的业务均是通过Python开发的 知乎: 国内最大的问答社区，通过Python开发(国外Quora) 春雨医生：国内知名的在线医疗网站是用Python开发的除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。 看完上面的介绍后是不是觉得python非常的厉害，各大公司都在应用python做开发，小到简单的模块功能，大到科学运算、人工智能、数据分析，无所不能一样，但是很遗憾，每种编程语言都有各自的优缺点，这是无法避免的，那接下来就看看python都有什么优缺点，可以快速的决定python是否适合自己使用 Python的优缺点先看优点: Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。 高级语言——当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性——由于它的开源本质，Python以及被移植到许多平台上（经过改动使它能够工作在不同平台上）。如果你小心的避免使用依赖于系统的特性，那么你的Python程序无需修改就几乎可以在市场上所有的系统平台上运行。 可扩展性——如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 可嵌入性——你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚步功能。 再看缺点： 速度慢，Python的运行速度相比C语言确实慢很多，跟Java相比也要慢一些，因此这是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来！ 代码不能加密，因为Python是解释性语言，它的源码都是以明文形式存放的，不过我不认为这算是一个缺点，如果你的项目源代码必须是加密的，那你一开始就不应该用Python来去实现。 线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在windows上为Win thread，完全由操作系统调度线程的执行。一个Python解释器进程内有一条主线路，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。 选python2还是python3了解完python的优缺点后，我们来了解下python现在的版本问题，到目前为止python官网出了两个版本，一个是python2，另一个是python3，而且这两个版本并不兼容，这也就意味着，如果你学的是python2，那么有些东西在python3是无法使用的，而且官网也明确说了，python2将不再维护更新，建议使用python3，所以这个问题，很明确，我们现在应该选择python3。 好了，关于python的介绍就到此为止了，虽然这些不需要我们记下来，但是，既然以后要开始学习python，起码应该了解python的一些课外内容，在下一篇文章，我们将学习如何安装python和编写我们的一个程序。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3从零开始]]></title>
    <url>%2Fpython3%2Fpython3%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[在写这篇文章的时候，我一直在想，我作为一名博客新人到底第一篇应该写点什么？因为本人也不是什么大神，我也很害怕自己写的不好，甚至害怕会误人子弟，所以我选择了第一篇就以python3为开端，虽然现在网上有许多的python的教程，也有很多的大神的文章，那么有人就会问了，“既然网上有那么多的python的教程了，为什么我还要写这种教程”，这个问题我也想过，大神的很多文章写的都很详细，而且他们的经验都比较丰富，但是有些教程时间很长了，有些东西已经过时了，或者有更加简单的方法，如果大家都还在看着过旧的教程，难免会造成误导，所以我写了一个python的教程系列，希望想学python的朋友能少走一些弯路。 前言本来打算将python的教程全部写在这篇文章里，后来想了下，如果全部写在一片文章里可能会造成文章的篇幅太大，而且不易分类和快速查找，所以我将这篇文章作为目录。 目录 python3从零开始_01:python简介 python3从零开始_02:python安装 python3从零开始_03:python基本数据类型 python3从零开始_04:python运算符 python3从零开始_05:元组 python3从零开始_06:列表]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>教程</tag>
        <tag>系列</tag>
      </tags>
  </entry>
</search>
